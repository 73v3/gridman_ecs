<assets.rs>
// assets.rs
use crate::components::GameState;
use bevy::audio::AudioSource;
use bevy::prelude::*;

pub struct AssetsPlugin;

impl Plugin for AssetsPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(OnEnter(GameState::Loading), load_assets);
    }
}

#[derive(Resource, Clone)]
pub struct Palette {
    pub colors: Vec<Color>,
}

#[derive(Resource)]
pub struct GameAssets {
    pub wall_texture: Handle<Image>,
    pub player_texture: Handle<Image>,
    pub reservation_texture: Handle<Image>,
    pub enemy_texture: Handle<Image>,
    pub explosion_texture: Handle<Image>,
    pub font: Handle<Font>,
    pub shoot_sfx: Handle<AudioSource>,
    pub explosion_sfx: Handle<AudioSource>,
    pub palette: Palette,
}

//use bevy::prelude::Color;

// Parses a hex color string (e.g., "#83769C" or "83769C") and returns a Color::Srgba
pub fn color_from_hex(hex: &str) -> Result<Color, &'static str> {
    // Remove optional '#' prefix
    let hex = hex.trim_start_matches('#');

    // Ensure the hex string is valid (6 or 8 characters for RGB or RGBA)
    if hex.len() != 6 && hex.len() != 8 {
        return Err("Hex string must be 6 (RGB) or 8 (RGBA) characters long");
    }

    // Parse the hex string into u8 values
    let r = u8::from_str_radix(&hex[0..2], 16).map_err(|_| "Invalid hex value for red")?;
    let g = u8::from_str_radix(&hex[2..4], 16).map_err(|_| "Invalid hex value for green")?;
    let b = u8::from_str_radix(&hex[4..6], 16).map_err(|_| "Invalid hex value for blue")?;

    // Handle alpha (default to 255 if not provided)
    let a = if hex.len() == 8 {
        u8::from_str_radix(&hex[6..8], 16).map_err(|_| "Invalid hex value for alpha")?
    } else {
        255
    };

    Ok(Color::srgba_u8(r, g, b, a))
}

fn load_assets(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    mut next_state: ResMut<NextState<GameState>>,
) {
    let palette = Palette {
        // https://lospec.com/palette-list/sweetie-16 by GrafxKid
        colors: vec![
            color_from_hex("#1a1c2c").unwrap(),
            color_from_hex("#5d275d").unwrap(),
            color_from_hex("#b13e53").unwrap(),
            color_from_hex("#ef7d57").unwrap(),
            color_from_hex("#ffcd75").unwrap(),
            color_from_hex("#a7f070").unwrap(),
            color_from_hex("#38b764").unwrap(),
            color_from_hex("#257179").unwrap(),
            color_from_hex("#29366f").unwrap(),
            color_from_hex("#3b5dc9").unwrap(),
            color_from_hex("#41a6f6").unwrap(),
            color_from_hex("#73eff7").unwrap(),
            color_from_hex("#f4f4f4").unwrap(),
            color_from_hex("#94b0c2").unwrap(),
            color_from_hex("#566c86").unwrap(),
            color_from_hex("#333c57").unwrap(),
        ],
    };

    commands.insert_resource(GameAssets {
        wall_texture: asset_server.load("textures/wall.png"),
        player_texture: asset_server.load("textures/player.png"),
        reservation_texture: asset_server.load("textures/reservation.png"),
        enemy_texture: asset_server.load("textures/enemy.png"),
        explosion_texture: asset_server.load("textures/explosion.png"),
        font: asset_server.load("fonts/press_start_2p/PressStart2P-Regular.ttf"),
        shoot_sfx: asset_server.load("sfx/shoot.wav"),
        explosion_sfx: asset_server.load("sfx/explosion.wav"),
        palette,
    });
    next_state.set(GameState::Title);
}
</assets.rs>

<audio.rs>
// audio.rs
use bevy::audio::{AudioPlayer, PlaybackSettings, Volume};
use bevy::prelude::*;

pub struct AudioPlugin;

impl Plugin for AudioPlugin {
    fn build(&self, _app: &mut App) {
        // No additional setup needed, as AudioPlugin is included in DefaultPlugins
    }
}

/// Plays a sound effect by spawning an entity that will despawn automatically after playback.
/// This is efficient for one-shot SFX and handles cleanup to avoid entity buildup.
pub fn play(commands: &mut Commands, audio: Handle<AudioSource>) {
    commands.spawn((AudioPlayer::new(audio), PlaybackSettings::DESPAWN));
}

pub fn play_with_volume(commands: &mut Commands, audio: Handle<AudioSource>, volume: f32) {
    commands.spawn((
        AudioPlayer::new(audio),
        PlaybackSettings {
            volume: Volume::Linear(volume),
            ..PlaybackSettings::DESPAWN
        },
    ));
}
</audio.rs>

<border.rs>
// border.rs
use crate::components::{GameEntity, GameState};
use crate::resolution::Resolution;
use crate::tilemap::{RENDERED_HEIGHT, RENDERED_WIDTH, TILE_SIZE};
use bevy::prelude::*;
use bevy::window::PrimaryWindow;

#[derive(Component)]
enum BorderSide {
    Left,
    Right,
    Top,
    Bottom,
}

pub struct BorderPlugin;

impl Plugin for BorderPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(
            OnEnter(GameState::Playing),
            (spawn_borders, update_borders).chain(), // Chain update_borders after spawn_borders
        )
        .add_systems(
            Update,
            update_borders.run_if(in_state(GameState::Playing).and(resource_changed::<Resolution>)),
        );
    }
}

fn spawn_borders(mut commands: Commands) {
    info!("Spawning borders for new game");
    let z_pos: f32 = 2.;

    commands.spawn((
        Sprite {
            color: Color::srgb(0.1, 0.1, 0.1),
            custom_size: Some(Vec2::ZERO),
            ..default()
        },
        Transform::from_xyz(0.0, 0.0, z_pos),
        BorderSide::Left,
        GameEntity,
    ));
    commands.spawn((
        Sprite {
            color: Color::srgb(0.1, 0.1, 0.1),
            custom_size: Some(Vec2::ZERO),
            ..default()
        },
        Transform::from_xyz(0.0, 0.0, z_pos),
        BorderSide::Right,
        GameEntity,
    ));
    commands.spawn((
        Sprite {
            color: Color::srgb(0.1, 0.1, 0.1),
            custom_size: Some(Vec2::ZERO),
            ..default()
        },
        Transform::from_xyz(0.0, 0.0, z_pos),
        BorderSide::Top,
        GameEntity,
    ));
    commands.spawn((
        Sprite {
            color: Color::srgb(0.1, 0.1, 0.1),
            custom_size: Some(Vec2::ZERO),
            ..default()
        },
        Transform::from_xyz(0.0, 0.0, z_pos),
        BorderSide::Bottom,
        GameEntity,
    ));
}

fn update_borders(
    windows: Query<&Window, With<PrimaryWindow>>,
    cameras: Query<(&Camera, &GlobalTransform), With<Camera2d>>,
    mut borders: Query<(&BorderSide, &mut Transform, &mut Sprite)>,
) {
    let Ok(_window) = windows.single() else {
        warn!("No primary window found in update_borders");
        return;
    };
    let Ok((camera, global_transform)) = cameras.single() else {
        warn!("No 2D camera found in update_borders");
        return;
    };

    let ndc_to_world = |ndc: Vec3| -> Vec3 {
        camera
            .ndc_to_world(global_transform, ndc)
            .unwrap_or(Vec3::ZERO)
    };

    let world_left = ndc_to_world(Vec3::new(-1.0, 0.0, 0.0)).x;
    let world_right = ndc_to_world(Vec3::new(1.0, 0.0, 0.0)).x;
    let world_bottom = ndc_to_world(Vec3::new(0.0, -1.0, 0.0)).y;
    let world_top = ndc_to_world(Vec3::new(0.0, 1.0, 0.0)).y;

    let tilemap_half_w = (RENDERED_WIDTH as f32 / 2.0) * TILE_SIZE;
    let tilemap_half_h = (RENDERED_HEIGHT as f32 / 2.0) * TILE_SIZE;

    let tilemap_left = -tilemap_half_w;
    let tilemap_right = tilemap_half_w - TILE_SIZE;
    let tilemap_bottom = -tilemap_half_h;
    let tilemap_top = tilemap_half_h - TILE_SIZE;

    for (side, mut transform, mut sprite) in &mut borders {
        match side {
            BorderSide::Left => {
                let width = (tilemap_left - world_left).max(0.0);
                let height = world_top - world_bottom;
                let pos_x = world_left + width / 2.0;
                let pos_y = (world_top + world_bottom) / 2.0;
                transform.translation = Vec3::new(pos_x, pos_y, transform.translation.z);
                sprite.custom_size = Some(Vec2::new(width, height));
            }
            BorderSide::Right => {
                let width = (world_right - tilemap_right).max(0.0);
                let height = world_top - world_bottom;
                let pos_x = tilemap_right + width / 2.0;
                let pos_y = (world_top + world_bottom) / 2.0;
                transform.translation = Vec3::new(pos_x, pos_y, transform.translation.z);
                sprite.custom_size = Some(Vec2::new(width, height));
            }
            BorderSide::Top => {
                let height = (world_top - tilemap_top).max(0.0);
                let width = world_right - world_left;
                let pos_y = tilemap_top + height / 2.0;
                let pos_x = (world_right + world_left) / 2.0;
                transform.translation = Vec3::new(pos_x, pos_y, transform.translation.z);
                sprite.custom_size = Some(Vec2::new(width, height));
            }
            BorderSide::Bottom => {
                let height = (tilemap_bottom - world_bottom).max(0.0);
                let width = world_right - world_left;
                let pos_y = world_bottom + height / 2.0;
                let pos_x = (world_right + world_left) / 2.0;
                transform.translation = Vec3::new(pos_x, pos_y, transform.translation.z);
                sprite.custom_size = Some(Vec2::new(width, height));
            }
        }
    }
}
</border.rs>

<collider.rs>
// collider.rs
use crate::components::{EnemyDied, GameState, PlayerDied};
use crate::enemy::Enemy;
use crate::grid_movement::GridMover;
use crate::grid_reservation::GridReservations;
use crate::player::Player;
use crate::projectile::{Bouncable, Projectile};
use bevy::prelude::*;

/// Component representing a collider with a size for AABB collision detection.
#[derive(Component)]
pub struct Collider {
    pub size: Vec2,
}

/// Event triggered when a projectile collides with another entity.
#[derive(Event)]
pub struct ProjectileCollision {
    pub projectile: Entity,
    pub victim: Entity,
}

/// The eight adjacent directions (cardinal and diagonal) for adjacency checks.
const DIRECTIONS: [IVec2; 8] = [
    IVec2::new(0, 1),   // Up
    IVec2::new(0, -1),  // Down
    IVec2::new(-1, 0),  // Left
    IVec2::new(1, 0),   // Right
    IVec2::new(-1, 1),  // Up-Left
    IVec2::new(1, 1),   // Up-Right
    IVec2::new(-1, -1), // Down-Left
    IVec2::new(1, -1),  // Down-Right
];

/// Expansion factor for player and enemy colliders during AABB checks.
const COLLIDER_EXPANSION_FACTOR: f32 = 2.25;

pub struct ColliderPlugin;

impl Plugin for ColliderPlugin {
    fn build(&self, app: &mut App) {
        app.add_event::<ProjectileCollision>().add_systems(
            Update,
            (
                check_projectile_collisions,
                check_player_enemy_adjacency
                    .after(crate::grid_movement::MovementSystems::UpdateMover),
            )
                .run_if(in_state(GameState::Playing)),
        );
    }
}

/// Checks for collisions between projectiles and other entities using the grid reservation system.
/// This is a highly efficient, targeted collision detection method.
fn check_projectile_collisions(
    mut events: EventWriter<ProjectileCollision>,
    reservations: Res<GridReservations>,
    projectiles: Query<(Entity, &Transform, &Collider, &GridMover, &Bouncable), With<Projectile>>,
    collidables: Query<(&Transform, &Collider)>,
    player_query: Query<(), With<Player>>,
) {
    for (proj_entity, proj_transform, proj_collider, proj_mover, bouncable) in &projectiles {
        // A projectile is only a threat if it's actively moving towards a new tile.
        if proj_mover.direction == IVec2::ZERO {
            continue;
        }

        // --- Broad Phase ---
        // Determine the tile the projectile is moving into.
        let target_tile = proj_mover.grid_pos + proj_mover.direction;

        // Check if this target tile is reserved by another entity.
        if let Some(&victim_entity) = reservations.0.get(&target_tile) {
            // --- Narrow Phase ---
            // We have a potential collision. Get the victim's components.
            // The .get() method on a Query is highly optimized.
            if let Ok((victim_transform, victim_collider)) = collidables.get(victim_entity) {
                // Check if the victim is the player and if the projectile hasn't bounced at least once.
                let is_player = player_query.get(victim_entity).is_ok();
                let bounced = bouncable.initial.saturating_sub(bouncable.remaining);
                if is_player && bounced < 1 {
                    continue; // Skip collision with player if projectile hasn't bounced.
                }

                // Perform the precise AABB check.
                if aabb_overlap(
                    proj_transform.translation.xy(),
                    proj_collider.size,
                    victim_transform.translation.xy(),
                    victim_collider.size,
                ) {
                    // Collision confirmed. Write the event.
                    events.write(ProjectileCollision {
                        projectile: proj_entity,
                        victim: victim_entity,
                    });
                }
            }
        }
    }
}

/// Checks for AABB overlap between the player and enemies in adjacent grid cells with expanded collider sizes.
/// Triggers player and enemy death if an overlap is detected.
fn check_player_enemy_adjacency(
    mut commands: Commands,
    mut player_died_events: EventWriter<PlayerDied>,
    mut enemy_died_events: EventWriter<EnemyDied>,
    player_query: Query<(Entity, &GridMover, &Transform, &Collider), With<Player>>,
    enemy_query: Query<(Entity, &Transform, &Collider), With<Enemy>>,
    reservations: Res<GridReservations>,
) {
    if let Ok((player_entity, player_mover, player_transform, player_collider)) =
        player_query.single()
    {
        // Check each adjacent cell using the constant DIRECTIONS array.
        for &dir in DIRECTIONS.iter() {
            let adjacent_pos = player_mover.grid_pos + dir;
            if let Some(&enemy_entity) = reservations.0.get(&adjacent_pos) {
                // Confirm the entity is an enemy.
                if let Ok((enemy_entity, enemy_transform, enemy_collider)) =
                    enemy_query.get(enemy_entity)
                {
                    // Perform AABB overlap check with expanded collider sizes.
                    if aabb_overlap(
                        player_transform.translation.xy(),
                        player_collider.size * COLLIDER_EXPANSION_FACTOR,
                        enemy_transform.translation.xy(),
                        enemy_collider.size * COLLIDER_EXPANSION_FACTOR,
                    ) {
                        // Collision detected; despawn both and trigger death events.
                        commands.entity(player_entity).despawn();
                        commands.entity(enemy_entity).despawn();
                        player_died_events.write(PlayerDied(player_transform.translation));
                        enemy_died_events.write(EnemyDied(enemy_transform.translation));
                        info!(
                            "Player died due to AABB overlap with enemy at {:?}",
                            adjacent_pos
                        );
                        // Break after first collision to avoid multiple death events in one frame.
                        break;
                    }
                }
            }
        }
    }
}

/// Checks for overlap between two Axis-Aligned Bounding Boxes.
pub fn aabb_overlap(pos1: Vec2, size1: Vec2, pos2: Vec2, size2: Vec2) -> bool {
    let half1 = size1 / 2.0;
    let half2 = size2 / 2.0;
    let min1 = pos1 - half1;
    let max1 = pos1 + half1;
    let min2 = pos2 - half2;
    let max2 = pos2 + half2;

    min1.x < max2.x && max1.x > min2.x && min1.y < max2.y && max1.y > min2.y
}
</collider.rs>

<components.rs>
use bevy::prelude::*;

#[derive(Clone, Copy, Default, Eq, PartialEq, Hash, States, Debug)]
pub enum GameState {
    #[default]
    Loading,
    Title,
    Playing,
}

#[derive(Component)]
pub struct GameEntity;

#[derive(Component)]
pub struct Velocity {
    pub velocity: Vec2,
}

#[derive(Component)]
pub struct Speed {
    pub value: f32,
}

#[derive(Event)]
pub struct PlayerDied(pub Vec3);

#[derive(Event)]
pub struct EnemyDied(pub Vec3);

#[derive(Resource)]
pub struct GameSpeed {
    pub value: f32,
}

pub struct ComponentsPlugin;

impl Plugin for ComponentsPlugin {
    fn build(&self, app: &mut App) {
        // Register the PlayerDied and EnemyDied events here.
        app.add_event::<PlayerDied>()
            .add_event::<EnemyDied>()
            .insert_resource(GameSpeed { value: 1.0 })
            .add_systems(
                Update,
                (update_velocity)
                    .chain()
                    .run_if(in_state(GameState::Playing)),
            );
    }
}

pub fn update_velocity(
    mut query: Query<(&Velocity, &mut Transform, Option<&Speed>)>,
    time: Res<Time>,
    game_speed: Res<GameSpeed>,
) {
    for (velocity, mut transform, speed) in query.iter_mut() {
        let speed_modifier = speed.map_or(1.0, |s| s.value) * game_speed.value;
        transform.translation.x += velocity.velocity.x * time.delta_secs() * speed_modifier;
        transform.translation.y += velocity.velocity.y * time.delta_secs() * speed_modifier;
    }
}
</components.rs>

<custom_window.rs>
// custom_window_plugin.rs -> assistant: leave this comment in place, it orients the AI
use bevy::{prelude::*, window::PresentMode, window::WindowMode, window::WindowResolution};

const GAME_TITLE: &str = "Gridman ECS";
const BACKGROUND_COLOR: Color = Color::srgb(0.1, 0.1, 0.1);

pub struct CustomWindowPlugin;

impl Plugin for CustomWindowPlugin {
    fn build(&self, app: &mut App) {
        app.insert_resource(ClearColor(BACKGROUND_COLOR))
            .add_plugins(
                DefaultPlugins
                    .set(bevy::window::WindowPlugin {
                        primary_window: Some(Window {
                            title: GAME_TITLE.to_string(),
                            present_mode: PresentMode::AutoNoVsync,
                            mode: WindowMode::Windowed,
                            position: WindowPosition::Centered(MonitorSelection::Primary),
                            resolution: WindowResolution::new(800.0, 600.0),
                            ..default()
                        }),
                        ..default()
                    })
                    .set(ImagePlugin::default_nearest()),
            )
            .add_systems(Update, close_on_esc);
    }
}

pub fn close_on_esc(
    mut commands: Commands,
    focused_windows: Query<(Entity, &Window)>,
    input: Res<ButtonInput<KeyCode>>,
) {
    for (window, focus) in focused_windows.iter() {
        if !focus.focused {
            continue;
        }

        if input.just_pressed(KeyCode::Escape) {
            commands.entity(window).despawn();
        }
    }
}
</custom_window.rs>

<debug.rs>
use crate::assets::GameAssets;
use crate::components::{GameEntity, GameState};
use bevy::diagnostic::{DiagnosticsStore, FrameTimeDiagnosticsPlugin};
use bevy::prelude::*;
use std::time::Duration;

pub struct DebugPlugin;

impl Plugin for DebugPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(OnEnter(GameState::Playing), setup_fps_display)
            .add_systems(
                Update,
                (update_fps_display, test_clear).run_if(in_state(GameState::Playing)),
            );
    }
}

#[derive(Component)]
struct FpsText;

fn setup_fps_display(mut commands: Commands, game_assets: Res<GameAssets>) {
    info!("Setting up FPS display");
    commands.spawn((
        Text::new("FPS: --"),
        TextFont {
            font: game_assets.font.clone(),
            font_size: 8.0,
            ..default()
        },
        TextColor(Color::srgb(0.9, 0.9, 0.9)), // Light gray for minimalist look
        TextLayout::new_with_justify(JustifyText::Left),
        Node {
            position_type: PositionType::Absolute,
            top: Val::Px(10.0),
            left: Val::Px(10.0),
            ..default()
        },
        BackgroundColor(Color::NONE),
        FpsText,
        GameEntity, // Ensures cleanup when exiting GameState::Playing
    ));
}

fn update_fps_display(
    diagnostics: Res<DiagnosticsStore>,
    mut query: Query<&mut Text, With<FpsText>>,
    time: Res<Time>,
    mut timer: Local<Timer>, // Local timer to track update interval
) {
    // Update every 0.5 seconds
    timer.tick(Duration::from_secs_f32(time.delta_secs()));
    if !timer.just_finished() {
        return;
    }
    timer.set_duration(Duration::from_secs_f32(0.5));
    timer.reset();

    if let Ok(mut text) = query.single_mut() {
        // Get FPS from diagnostics
        if let Some(fps) = diagnostics
            .get(&FrameTimeDiagnosticsPlugin::FPS)
            .and_then(|fps| fps.smoothed())
        {
            text.0 = format!("FPS: {:.0}", fps);
        } else {
            info!("FPS diagnostic not available");
            text.0 = "FPS: --".to_string();
        }
    }
}

fn test_clear(keys: Res<ButtonInput<KeyCode>>) {
    if keys.just_pressed(KeyCode::End) {
        info!("END pressed");
    }
}
</debug.rs>

<diagnostics.rs>
// diagnostics.rs
use bevy::{diagnostic::FrameTimeDiagnosticsPlugin, prelude::*};

pub struct DiagnosticsPlugin;

impl Plugin for DiagnosticsPlugin {
    fn build(&self, app: &mut App) {
        app
            // Adds frame time diagnostics (FPS, frame time, etc.)
            .add_plugins(FrameTimeDiagnosticsPlugin::default());
        // Logs diagnostics to the console at regular intervals
        //.add_plugins(LogDiagnosticsPlugin::default())
        // Optional diagnostic plugins (uncomment to enable)
        // .add_plugins(bevy::diagnostic::EntityCountDiagnosticsPlugin::default())
        // .add_plugins(bevy::asset::diagnostic::AssetCountDiagnosticsPlugin::<Texture>::default())
        // .add_plugins(bevy::diagnostic::SystemInformationDiagnosticsPlugin::default());
        //
    }
}
</diagnostics.rs>

<enemy.rs>
// enemy.rs

//! Manages enemy spawning, AI, and behavior.

use bevy::prelude::*;
use bevy_rand::prelude::{GlobalEntropy, WyRand};

use crate::assets::GameAssets;
use crate::collider::Collider;
use crate::components::{GameEntity, GameState};
use crate::grid_movement::{self, GridMover, IntendedDirection, MovementSystems};
use crate::grid_reservation::{GridReservations, GridReserver};
use crate::map::MapData;
use crate::player::DEFAULT_PLAYER_SPEED;
use crate::random::{random_colour, random_float};
use crate::tilemap::TILE_SIZE;

const NUM_LEFT_TURNERS: u32 = 150;
const NUM_RIGHT_TURNERS: u32 = NUM_LEFT_TURNERS;

const DEFAULT_ENEMY_SPEED: f32 = 0.5 * DEFAULT_PLAYER_SPEED;

/// A plugin for all enemy-related logic.
pub struct EnemyPlugin;

impl Plugin for EnemyPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(OnEnter(GameState::Title), setup_enemy_colors)
            .add_systems(OnEnter(GameState::Playing), spawn_enemies)
            .configure_sets(
                Update,
                // The AI systems must run before the movement system to avoid a 1-frame delay.
                EnemyMovementAI.before(MovementSystems::UpdateMover),
            )
            .add_systems(
                Update,
                (update_left_turners, update_right_turners)
                    .in_set(EnemyMovementAI)
                    .run_if(in_state(GameState::Playing)),
            );
    }
}

/// A SystemSet for enemy AI logic to ensure it runs before movement is executed.
#[derive(SystemSet, Debug, Hash, PartialEq, Eq, Clone)]
pub struct EnemyMovementAI;

/// A marker component for any enemy entity.
#[derive(Component)]
pub struct Enemy;

/// A stateful component for enemies that prefer turning left.
#[derive(Component)]
pub struct LeftTurner {
    /// The last direction the enemy was intentionally moving.
    /// This is crucial for making turn decisions after being stopped by a collision.
    pub last_known_direction: IVec2,
}

/// A stateful component for enemies that prefer turning right.
#[derive(Component)]
pub struct RightTurner {
    /// The last direction the enemy was intentionally moving.
    pub last_known_direction: IVec2,
}

/// A resource to store the globally chosen colors for each enemy type.
#[derive(Resource)]
pub struct EnemyColors {
    pub left_turner: Color,
    pub right_turner: Color,
}

/// Runs once to select and store the colors for enemies.
fn setup_enemy_colors(
    mut commands: Commands,
    game_assets: Res<GameAssets>,
    mut rng: GlobalEntropy<WyRand>,
) {
    let color_a = random_colour(&mut rng, &game_assets);
    let mut color_b = random_colour(&mut rng, &game_assets);
    // Ensure the two colors are different.
    while color_a == color_b {
        color_b = random_colour(&mut rng, &game_assets);
    }
    commands.insert_resource(EnemyColors {
        left_turner: color_a,
        right_turner: color_b,
    });
}

/// Spawns all initial enemies in random, valid locations.
fn spawn_enemies(
    mut commands: Commands,
    game_assets: Res<GameAssets>,
    mut rng: GlobalEntropy<WyRand>,
    map_data: Res<MapData>,
    mut reservations: ResMut<GridReservations>,
    enemy_colors: Res<EnemyColors>,
) {
    let valid_directions = [
        IVec2::new(0, 1),
        IVec2::new(0, -1),
        IVec2::new(1, 0),
        IVec2::new(-1, 0),
    ];

    // Spawn LeftTurners
    for _ in 0..NUM_LEFT_TURNERS {
        let (spawn_pos, start_dir) =
            find_valid_spawn(&mut rng, &map_data, &reservations, &valid_directions);

        let entity = commands
            .spawn((
                Sprite {
                    color: enemy_colors.left_turner,
                    image: game_assets.enemy_texture.clone(),
                    ..default()
                },
                Transform::from_xyz(0.0, 0.0, 0.9),
                Enemy,
                GridMover {
                    grid_pos: spawn_pos,
                    direction: IVec2::ZERO,
                    progress: 0.0,
                    speed: DEFAULT_ENEMY_SPEED,
                },
                IntendedDirection(start_dir),
                LeftTurner {
                    last_known_direction: start_dir,
                },
                GridReserver,
                Collider {
                    size: Vec2::splat(TILE_SIZE * 0.5),
                },
                GameEntity,
            ))
            .id();
        reservations.0.insert(spawn_pos, entity);
    }

    // Spawn RightTurners
    for _ in 0..NUM_RIGHT_TURNERS {
        let (spawn_pos, start_dir) =
            find_valid_spawn(&mut rng, &map_data, &reservations, &valid_directions);

        let entity = commands
            .spawn((
                Sprite {
                    color: enemy_colors.right_turner,
                    image: game_assets.enemy_texture.clone(),
                    ..default()
                },
                Transform::from_xyz(0.0, 0.0, 0.9),
                Enemy,
                GridMover {
                    grid_pos: spawn_pos,
                    direction: IVec2::ZERO,
                    progress: 0.0,
                    speed: DEFAULT_ENEMY_SPEED,
                },
                IntendedDirection(start_dir),
                RightTurner {
                    last_known_direction: start_dir,
                },
                GridReserver,
                Collider {
                    size: Vec2::splat(TILE_SIZE * 0.5),
                },
                GameEntity,
            ))
            .id();
        reservations.0.insert(spawn_pos, entity);
    }
}

/// The AI system for LeftTurner enemies.
/// It decides on a new direction when the current path is blocked.
fn update_left_turners(
    mut query: Query<(Entity, &mut IntendedDirection, &GridMover, &mut LeftTurner)>,
    reservations: Res<GridReservations>,
    map_data: Res<MapData>,
) {
    for (entity, mut intended, mover, mut turner) in &mut query {
        // If the entity is moving, update its last known direction and do nothing else.
        if intended.0 != IVec2::ZERO {
            turner.last_known_direction = intended.0;
            continue;
        }

        // The entity has been stopped. Decide where to go next based on its last direction.
        let forward_dir = turner.last_known_direction;
        let current_pos = mover.grid_pos;

        // Priority: Left, Right, Back.
        let left_dir = IVec2::new(forward_dir.y, -forward_dir.x);
        let right_dir = IVec2::new(-forward_dir.y, forward_dir.x);
        let back_dir = -forward_dir;

        let new_dir = if !is_blocked(current_pos + left_dir, entity, &reservations, &map_data) {
            left_dir
        } else if !is_blocked(current_pos + right_dir, entity, &reservations, &map_data) {
            right_dir
        } else {
            back_dir
        };

        intended.0 = new_dir;
        turner.last_known_direction = new_dir;
    }
}

/// The AI system for RightTurner enemies.
/// It decides on a new direction when the current path is blocked.
fn update_right_turners(
    mut query: Query<(Entity, &mut IntendedDirection, &GridMover, &mut RightTurner)>,
    reservations: Res<GridReservations>,
    map_data: Res<MapData>,
) {
    for (entity, mut intended, mover, mut turner) in &mut query {
        // If the entity is moving, update its last known direction and do nothing else.
        if intended.0 != IVec2::ZERO {
            turner.last_known_direction = intended.0;
            continue;
        }

        // The entity has been stopped. Decide where to go next based on its last direction.
        let forward_dir = turner.last_known_direction;
        let current_pos = mover.grid_pos;

        // Priority: Right, Left, Back.
        let right_dir = IVec2::new(-forward_dir.y, forward_dir.x);
        let left_dir = IVec2::new(forward_dir.y, -forward_dir.x);
        let back_dir = -forward_dir;

        let new_dir = if !is_blocked(current_pos + right_dir, entity, &reservations, &map_data) {
            right_dir
        } else if !is_blocked(current_pos + left_dir, entity, &reservations, &map_data) {
            left_dir
        } else {
            back_dir
        };

        intended.0 = new_dir;
        turner.last_known_direction = new_dir;
    }
}

/// Helper to check if a target grid cell is a wall or reserved by another entity.
fn is_blocked(
    target_pos: IVec2,
    self_entity: Entity,
    reservations: &GridReservations,
    map_data: &MapData,
) -> bool {
    if grid_movement::is_wall(target_pos, map_data) {
        return true;
    }
    if let Some(&occupant) = reservations.0.get(&target_pos) {
        // A tile is only blocked if another entity occupies it.
        if occupant != self_entity {
            return true;
        }
    }
    false
}

/// Finds a random, non-wall, non-reserved grid cell to spawn an entity.
fn find_valid_spawn(
    rng: &mut GlobalEntropy<WyRand>,
    map_data: &MapData,
    reservations: &GridReservations,
    directions: &[IVec2],
) -> (IVec2, IVec2) {
    let width = map_data.width as i32;
    let height = map_data.height as i32;

    loop {
        let x = (random_float(rng) * width as f32) as i32;
        let y = (random_float(rng) * height as f32) as i32;
        let pos = IVec2::new(x, y);

        if !grid_movement::is_wall(pos, map_data) && !reservations.0.contains_key(&pos) {
            // Found a valid position. Now find a valid starting direction.
            let start_idx = (random_float(rng) * directions.len() as f32) as usize;
            for i in 0..directions.len() {
                let dir = directions[(start_idx + i) % directions.len()];
                if !grid_movement::is_wall(pos + dir, map_data) {
                    return (pos, dir);
                }
            }
            // If all directions are blocked, we'll loop and find a new spawn point.
        }
    }
}
</enemy.rs>

<explosion.rs>
use crate::assets::GameAssets;
use crate::audio;
use crate::components::{EnemyDied, GameEntity, GameSpeed, GameState, PlayerDied};
use crate::random::{random_colour, random_float};
use bevy::prelude::*;
use bevy_rand::prelude::{GlobalEntropy, WyRand};

pub struct ExplosionPlugin;

impl Plugin for ExplosionPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(
            Update,
            (
                spawn_enemy_explosions,
                spawn_player_explosions,
                update_explosions,
                check_player_explosions,
            )
                .chain()
                .run_if(in_state(GameState::Playing)),
        );
    }
}

#[derive(Component)]
pub struct Explosion {
    pub timer: f32,
}

#[derive(Component)]
pub struct PlayerExplosion;

#[derive(Resource)]
pub struct PlayerIsDead;

const EXPLOSION_LIFETIME: f32 = 0.375;

// spawns an explosion at the position of any enemy that has just died
fn spawn_enemy_explosions(
    mut commands: Commands,
    mut dead_events: EventReader<EnemyDied>,
    game_assets: Res<GameAssets>,
    mut rng: GlobalEntropy<WyRand>,
) {
    for EnemyDied(pos) in dead_events.read() {
        audio::play_with_volume(&mut commands, game_assets.explosion_sfx.clone(), 0.3);
        commands.spawn((
            Sprite {
                image: game_assets.explosion_texture.clone(),
                color: random_colour(&mut rng, &game_assets),
                ..Default::default()
            },
            Transform::from_translation(*pos),
            Explosion { timer: 0.0 },
            GameEntity,
        ));
    }
}

const NUM_PLAYER_EXPLOSIONS: i32 = 16;

// spawns multiple explosions at player's location
fn spawn_player_explosions(
    mut commands: Commands,
    mut player_died_events: EventReader<PlayerDied>,
    game_assets: Res<GameAssets>,
    mut rng: GlobalEntropy<WyRand>,
) {
    for PlayerDied(pos) in player_died_events.read() {
        info!("player died");
        audio::play_with_volume(&mut commands, game_assets.explosion_sfx.clone(), 0.5);
        for _ in 0..NUM_PLAYER_EXPLOSIONS {
            let offset_x = (random_float(&mut rng) - 0.5) * 20.0;
            let offset_y = (random_float(&mut rng) - 0.5) * 20.0;
            commands.spawn((
                Sprite {
                    image: game_assets.explosion_texture.clone(),
                    color: random_colour(&mut rng, &game_assets),
                    ..Default::default()
                },
                Transform::from_translation(*pos + Vec3::new(offset_x, offset_y, 0.)),
                Explosion {
                    timer: -2. * random_float(&mut rng), // stagger the explosion dissipation over time
                },
                PlayerExplosion,
                GameEntity,
            ));
        }
        commands.insert_resource(PlayerIsDead);
    }
}

// fades out explosions over time, despawning when done
fn update_explosions(
    mut commands: Commands,
    mut query: Query<(Entity, &mut Explosion, &mut Sprite)>,
    time: Res<Time>,
) {
    for (entity, mut explosion, mut sprite) in query.iter_mut() {
        explosion.timer += time.delta_secs();
        if explosion.timer > EXPLOSION_LIFETIME {
            commands.entity(entity).despawn();
        } else {
            let alpha = if explosion.timer < EXPLOSION_LIFETIME / 2.0 {
                1.0
            } else {
                1.0 - (explosion.timer - EXPLOSION_LIFETIME / 2.0) / (EXPLOSION_LIFETIME / 2.0)
            };
            sprite.color = sprite.color.with_alpha(alpha);
        }
    }
}

// checks if the player is dead and player explosions have finished,
// in which case, return to title screen
fn check_player_explosions(
    mut commands: Commands,
    option_dead: Option<Res<PlayerIsDead>>,
    player_explosion_query: Query<Entity, With<PlayerExplosion>>,
    mut next_state: ResMut<NextState<GameState>>,
    mut game_speed: ResMut<GameSpeed>,
) {
    if let Some(_) = option_dead {
        if player_explosion_query.is_empty() {
            next_state.set(GameState::Title);
            game_speed.value = 1.0;
            commands.remove_resource::<PlayerIsDead>();
            info!("player dead::switching to title");
        }
    }
}
</explosion.rs>

<game.rs>
use bevy::prelude::*;

use crate::assets;
use crate::audio;
use crate::border;
use crate::collate_src;
use crate::collider;
use crate::components;
use crate::debug;
use crate::diagnostics;
use crate::enemy;
use crate::explosion;
use crate::grid_movement;
use crate::grid_reservation;
use crate::map;
use crate::player;
use crate::projectile;
use crate::random;
use crate::resolution;
use crate::score;
use crate::tilemap;
use crate::title;
use crate::ui_scaling;
pub struct GamePlugin;

impl Plugin for GamePlugin {
    fn build(&self, app: &mut App) {
        app.add_plugins((
            // max of 15 plugins in a tuple
            collate_src::CollateSrcPlugin,
            components::ComponentsPlugin,
            resolution::ResolutionPlugin,
            random::RandomPlugin,
            title::TitlePlugin,
            assets::AssetsPlugin,
            score::ScorePlugin,
            audio::AudioPlugin,
            debug::DebugPlugin,
            ui_scaling::UiScalingPlugin,
            tilemap::TilemapPlugin,
            map::MapPlugin,
            player::PlayerPlugin,
            grid_movement::GridMovementPlugin,
            collider::ColliderPlugin,
        ))
        .add_plugins((
            projectile::ProjectilePlugin,
            border::BorderPlugin,
            grid_reservation::GridReservationPlugin,
            enemy::EnemyPlugin,
            diagnostics::DiagnosticsPlugin,
            explosion::ExplosionPlugin,
        ))
        .add_systems(Startup, setup_scene);
    }
}

fn setup_scene(mut commands: Commands) {
    commands.spawn(Camera2d::default());
}
</game.rs>

<grid_movement.rs>
// grid_movement.rs

//! This module defines the core logic for entity movement on a grid.
//!
//! It introduces the `GridMover` component, which tracks an entity's discrete grid position
//! and its progress toward the next tile. The module provides systems to update this state
//! based on an `IntendedDirection` (set by player input or AI), handle wall collisions,
//! and translate the logical grid position into a smooth, visual world position (`Transform`).
//! A `SystemSet` is used to ensure a deterministic order of operations for movement logic.

use bevy::ecs::schedule::SystemSet;
use bevy::prelude::*;

use crate::components::GameState;
use crate::grid_reservation::{GridReservations, GridReserver};
use crate::map::MapData;
use crate::projectile::{Bouncable, Projectile};
use crate::tilemap::{MapOffset, TileOffset, HALF_HEIGHT, HALF_WIDTH, TILE_SIZE};

/// A component that enables grid-based movement for an entity.
#[derive(Component)]
pub struct GridMover {
    /// The entity's current position in integer grid coordinates.
    pub grid_pos: IVec2,
    /// The direction the entity is currently moving (e.g., (1, 0) for right).
    /// A zero vector indicates the entity is stationary.
    pub direction: IVec2,
    /// The progress (0.0 to 1.0) of the movement from `grid_pos` to the next tile.
    /// 0.0 means the entity is perfectly on `grid_pos`; 1.0 means it has arrived at the next tile.
    pub progress: f32,
    /// The speed of the entity, measured in how many pixels it would travel per second.
    /// This is used to calculate the increment of `progress` each frame.
    pub speed: f32,
}

/// A component representing the desired direction of movement for an entity.
///
/// This is decoupled from `GridMover.direction` to allow for input buffering.
/// For example, a player can press a new direction key before the entity has
/// finished moving to the current tile.
#[derive(Component)]
pub struct IntendedDirection(pub IVec2);

/// Defines a strict order of execution for systems related to movement.
///
/// This is crucial to prevent issues like one-frame delays between input and movement,
/// or the camera position being updated before the player's transform. The `.chain()`
/// ensures these sets run sequentially within a single frame.
#[derive(SystemSet, Debug, Hash, PartialEq, Eq, Clone)]
pub enum MovementSystems {
    /// Handles reading input from players or AI to set `IntendedDirection`.
    Input,
    /// Updates the `GridMover` state (progress, direction) based on `IntendedDirection`.
    UpdateMover,
    /// Translates the `GridMover` state into a world-space `Transform` for rendering.
    UpdatePosition,
    /// Adjusts camera/viewport scrolling based on the final entity position.
    AdjustScroll,
    /// Applies any changes to offsets to entity positions.
    ApplyOffsetChanges,
}

/// The plugin that adds all grid movement logic to the application.
pub struct GridMovementPlugin;

impl Plugin for GridMovementPlugin {
    fn build(&self, app: &mut App) {
        app
            // Configure the order of our system sets.
            .configure_sets(
                Update,
                (
                    MovementSystems::Input,
                    MovementSystems::UpdateMover.after(MovementSystems::Input),
                    MovementSystems::UpdatePosition.after(MovementSystems::UpdateMover),
                    MovementSystems::AdjustScroll.after(MovementSystems::UpdatePosition),
                    MovementSystems::ApplyOffsetChanges.after(MovementSystems::AdjustScroll),
                )
                    .chain()
                    .run_if(in_state(GameState::Playing)),
            )
            // Add the systems to their respective sets.
            .add_systems(
                Update,
                update_grid_movement.in_set(MovementSystems::UpdateMover),
            )
            .add_systems(
                Update,
                update_grid_positions.in_set(MovementSystems::UpdatePosition),
            )
            .add_systems(
                Update,
                update_grid_positions
                    .run_if(resource_changed::<MapOffset>.or(resource_changed::<TileOffset>))
                    .in_set(MovementSystems::ApplyOffsetChanges),
            );
    }
}

/// The core system that updates the state of all `GridMover` components.
///
/// This system functions like a state machine for each moving entity. It handles:
/// - Starting movement from a standstill.
/// - Advancing movement progress frame-by-frame.
/// - Reaching a destination tile and deciding what to do next (stop, continue, or change direction).
/// - Handling collisions with walls, including logic for bouncing projectiles.
/// The core system that updates the state of all GridMover components.
#[allow(clippy::too_many_arguments)]
fn update_grid_movement(
    mut commands: Commands,
    mut query: Query<(
        Entity,
        &mut GridMover,
        &mut IntendedDirection,
        Option<&GridReserver>,
        Option<&mut Bouncable>,
        Option<&Projectile>,
    )>,
    time: Res<Time>,
    map_data: Res<MapData>,
    mut reservations: ResMut<GridReservations>,
) {
    for (entity, mut mover, mut intended, reserver, bouncable, projectile) in &mut query {
        // --- State 1: Entity is stationary ---
        if mover.direction == IVec2::ZERO {
            let new_dir = intended.0;
            if new_dir != IVec2::ZERO {
                let next_tile = mover.grid_pos + new_dir;
                // Check if the target tile is valid for movement.
                let is_tile_wall = is_wall(next_tile, &map_data);
                let mut is_tile_reserved = false;

                // Only check for reservations if the entity is a GridReserver.
                if reserver.is_some() {
                    if let Some(&occupant) = reservations.0.get(&next_tile) {
                        // A tile is only considered reserved if it's occupied by another entity.
                        is_tile_reserved = occupant != entity;
                    }
                }

                // Only start moving if the target tile is not a wall and not reserved.
                if !is_tile_wall && !is_tile_reserved {
                    mover.direction = new_dir;
                    mover.progress = 0.0;
                    // If this is a reserver, claim the destination tile.
                    if reserver.is_some() {
                        reservations.0.insert(next_tile, entity);
                    }
                }
            }
        // --- State 2: Entity is currently moving between tiles ---
        } else {
            // Calculate how much to increment progress this frame.
            let dir_vec = mover.direction.as_vec2();
            let dist_factor = dir_vec.length();
            if dist_factor == 0.0 {
                continue; // Avoid division by zero if direction is somehow zero here.
            }
            let inc = mover.speed * time.delta_secs() / (TILE_SIZE * dist_factor);
            mover.progress += inc;

            // --- State 3: Entity has arrived at or passed the destination tile ---
            if mover.progress >= 1.0 {
                let old_pos = mover.grid_pos;
                let current_direction = mover.direction;
                mover.grid_pos += current_direction; // Lock position to the new grid tile.

                // If this entity reserves tiles, free the one it just left.
                if reserver.is_some() {
                    // Only remove the reservation if this entity was the one holding it.
                    if let Some(&occupant) = reservations.0.get(&old_pos) {
                        if occupant == entity {
                            reservations.0.remove(&old_pos);
                        }
                    }
                }

                // Check if the entity wants to continue in the same direction.
                let is_continuing =
                    intended.0 == current_direction && current_direction != IVec2::ZERO;

                if is_continuing {
                    let next_tile = mover.grid_pos + current_direction;
                    let is_tile_wall = is_wall(next_tile, &map_data);
                    let mut is_tile_reserved = false;

                    // Check for reservations if the entity is a GridReserver.
                    if reserver.is_some() {
                        if let Some(&occupant) = reservations.0.get(&next_tile) {
                            is_tile_reserved = occupant != entity;
                        }
                    }

                    if !is_tile_wall && !is_tile_reserved {
                        // Path is clear: carry over the "excess" progress for a smooth transition.
                        mover.progress -= 1.0;
                        // Reserve the new destination tile if this entity is a GridReserver.
                        if reserver.is_some() {
                            reservations.0.insert(next_tile, entity);
                        }
                    } else {
                        // Wall or reserved tile detected ahead.
                        let can_bounce = bouncable.as_ref().map_or(false, |b| b.remaining > 0);
                        if can_bounce {
                            // --- Bouncing Logic ---
                            let new_dir =
                                calculate_reflection(current_direction, mover.grid_pos, &map_data);
                            mover.direction = new_dir;
                            intended.0 = new_dir;
                            if let Some(mut b) = bouncable {
                                b.remaining -= 1;
                            }
                            // Adjust progress based on new direction's length to maintain speed.
                            let old_length = current_direction.as_vec2().length();
                            let new_length = new_dir.as_vec2().length();
                            mover.progress -= 1.0;
                            if new_length > 0.0 && old_length > 0.0 {
                                mover.progress *= old_length / new_length;
                            }
                            // Reserve the new tile after bouncing if this is a reserver.
                            if reserver.is_some() {
                                let next_tile = mover.grid_pos + new_dir;
                                if !is_wall(next_tile, &map_data) {
                                    reservations.0.insert(next_tile, entity);
                                }
                            }
                        } else {
                            // Cannot bounce: stop movement.
                            mover.progress = 0.0;
                            mover.direction = IVec2::ZERO;
                            intended.0 = IVec2::ZERO;
                            // If it's a projectile, despawn it on impact.
                            if projectile.is_some() {
                                commands.entity(entity).despawn();
                            }
                        }
                    }
                } else {
                    // Not continuing straight: reset progress and check for a new direction.
                    mover.progress = 0.0;
                    let new_dir = intended.0;
                    if new_dir != IVec2::ZERO {
                        let next_tile = mover.grid_pos + new_dir;
                        let is_tile_wall = is_wall(next_tile, &map_data);
                        let mut is_tile_reserved = false;

                        // Check for reservations if the entity is a GridReserver.
                        if reserver.is_some() {
                            if let Some(&occupant) = reservations.0.get(&next_tile) {
                                is_tile_reserved = occupant != entity;
                            }
                        }

                        if !is_tile_wall && !is_tile_reserved {
                            mover.direction = new_dir; // Start moving in the new intended direction.
                                                       // Reserve the new destination tile if this is a reserver.
                            if reserver.is_some() {
                                reservations.0.insert(next_tile, entity);
                            }
                        } else {
                            mover.direction = IVec2::ZERO; // New direction is blocked, so stop.
                        }
                    } else {
                        mover.direction = IVec2::ZERO; // No new direction, so stop.
                    }
                }
            }
        }
    }
}

/// Calculates a simple reflection vector for bouncing.
///
/// It checks for open paths horizontally and vertically from the point of impact.
/// - If the horizontal path is clear, it reflects vertically (y -> -y).
/// - If the vertical path is clear, it reflects horizontally (x -> -x).
/// - If both are blocked (a corner), it reflects both (x -> -x, y -> -y).
fn calculate_reflection(dir: IVec2, grid_pos: IVec2, map_data: &MapData) -> IVec2 {
    let dx = dir.x;
    let dy = dir.y;

    // Check adjacent tiles in the direction of velocity components.
    let horiz_next = grid_pos + IVec2::new(dx, 0);
    let vert_next = grid_pos + IVec2::new(0, dy);
    let horiz_clear = !is_wall(horiz_next, map_data);
    let vert_clear = !is_wall(vert_next, map_data);

    if horiz_clear {
        IVec2::new(dx, -dy) // Reflect vertically
    } else if vert_clear {
        IVec2::new(-dx, dy) // Reflect horizontally
    } else {
        IVec2::new(-dx, -dy) // Reflect fully (corner hit)
    }
}

/// Translates the logical `GridMover` position into a final `Transform` for rendering.
///
/// This system runs after `update_grid_movement`, ensuring it uses the most up-to-date
/// grid position and progress. It accounts for the global map and tile offsets to correctly
/// position the entity within the camera's viewport.
fn update_grid_positions(
    map_offset: Res<MapOffset>,
    tile_offset: Res<TileOffset>,
    mut query: Query<(&GridMover, &mut Transform)>,
) {
    for (mover, mut trans) in &mut query {
        // Calculate the effective position, including the fractional progress towards the next tile.
        let effective_pos = mover.grid_pos.as_vec2() + mover.direction.as_vec2() * mover.progress;

        // Convert the effective grid position to world coordinates.
        let x =
            (effective_pos.x - map_offset.0.x as f32 - HALF_WIDTH) * TILE_SIZE + tile_offset.0.x;
        let y =
            (effective_pos.y - map_offset.0.y as f32 - HALF_HEIGHT) * TILE_SIZE + tile_offset.0.y;

        trans.translation.x = x;
        trans.translation.y = y;
    }
}

/// A utility function to check if a given grid position is a wall or out of bounds.
///
/// It performs bounds checking and then looks up the tile type in the `MapData` resource.
/// The Y-coordinate is flipped because the map image data is loaded with (0,0) at the top-left,
/// while our grid coordinates treat (0,0) as the bottom-left.
pub fn is_wall(pos: IVec2, map: &MapData) -> bool {
    // Treat any position outside the map boundaries as a wall.
    if pos.x < 0 || pos.y < 0 || pos.x >= map.width as i32 || pos.y >= map.height as i32 {
        return true;
    }
    let x = pos.x as u32;
    let y = pos.y as u32;

    // Flip Y for lookup in the map data vector.
    let flipped_y = map.height - 1 - y;
    let idx = (flipped_y * map.width + x) as usize;

    // Safely get the value, defaulting to `true` (wall) if the index is somehow out of bounds.
    map.is_wall.get(idx).copied().unwrap_or(true)
}
</grid_movement.rs>

<grid_reservation.rs>
// src/grid_reservation.rs
use crate::assets::GameAssets;
use crate::components::{GameEntity, GameState};
use crate::tilemap::{MapOffset, TileOffset, HALF_HEIGHT, HALF_WIDTH, TILE_SIZE};
use bevy::prelude::*;
use std::collections::{HashMap, HashSet};

/// When set to true, spawns a sprite for each grid cell reservation for debugging.
const VISUAL_DEBUG_RESERVATIONS: bool = !true;

pub struct GridReservationPlugin;

impl Plugin for GridReservationPlugin {
    fn build(&self, app: &mut App) {
        app.init_resource::<GridReservations>()
            // This system runs after all other updates, ensuring that it catches any
            // entities that were despawned during the frame.
            .add_systems(PostUpdate, cleanup_dangling_reservations);

        // If the debug flag is enabled, add the visualization systems.
        if VISUAL_DEBUG_RESERVATIONS {
            app.add_systems(
                Update,
                (sync_reservation_visuals, update_visualizer_positions)
                    .chain()
                    .run_if(in_state(GameState::Playing)),
            );
        }
    }
}

/// A resource that stores a map of reserved grid cells to the entity reserving them.
/// This provides a fast, centralized lookup for collision avoidance.
#[derive(Resource, Default)]
pub struct GridReservations(pub HashMap<IVec2, Entity>);

/// A marker component for entities that should reserve their grid cells.
/// Entities with this component will be unable to move into cells reserved
/// by other entities that also have this component.
#[derive(Component)]
pub struct GridReserver;

/// A marker component for the visual sprite representing a reservation.
/// Stores the grid position it corresponds to.
#[derive(Component)]
struct ReservationVisualizer(IVec2);

/// Spawns and despawns sprites to match the current state of GridReservations.
fn sync_reservation_visuals(
    mut commands: Commands,
    reservations: Res<GridReservations>,
    game_assets: Res<GameAssets>,
    // Query for all existing visualizer entities
    visualizer_query: Query<(Entity, &ReservationVisualizer)>,
) {
    // Collect all grid positions that are currently reserved.
    let needed_visuals: HashSet<IVec2> = reservations.0.keys().cloned().collect();

    // Collect all grid positions that currently have a visualizer sprite.
    let mut current_visuals: HashMap<IVec2, Entity> = HashMap::new();
    for (entity, visualizer) in &visualizer_query {
        current_visuals.insert(visualizer.0, entity);
    }

    // Despawn unneeded visualizers by finding which current ones are no longer needed.
    for (pos, entity) in &current_visuals {
        if !needed_visuals.contains(pos) {
            // Use .despawn() which is idiomatic for Bevy 0.16+
            commands.entity(*entity).despawn();
        }
    }

    // Spawn new visualizers where needed by finding which needed ones don't exist yet.
    for pos in needed_visuals {
        if !current_visuals.contains_key(&pos) {
            commands.spawn((
                Sprite {
                    image: game_assets.reservation_texture.clone(),
                    ..default()
                },
                ReservationVisualizer(pos),
                // GameEntity ensures it's cleaned up when we exit the Playing state.
                GameEntity,
                // The transform will be set correctly by the update_visualizer_positions system.
                // A high Z-value ensures it renders on top of the floor and player.
                Transform::from_xyz(0.0, 0.0, 1.5),
            ));
        }
    }
}

/// Updates the world-space transform of each visualizer sprite based on its grid position
/// and the current camera scroll offsets.
fn update_visualizer_positions(
    map_offset: Res<MapOffset>,
    tile_offset: Res<TileOffset>,
    mut query: Query<(&ReservationVisualizer, &mut Transform)>,
) {
    for (visualizer, mut trans) in &mut query {
        let pos = visualizer.0;

        // This calculation is identical to how other grid-based entities are positioned,
        // ensuring the debug sprite is perfectly centered on the tile.
        let x = (pos.x as f32 - map_offset.0.x as f32 - HALF_WIDTH) * TILE_SIZE + tile_offset.0.x;
        let y = (pos.y as f32 - map_offset.0.y as f32 - HALF_HEIGHT) * TILE_SIZE + tile_offset.0.y;

        trans.translation.x = x;
        trans.translation.y = y;
    }
}

/// A system that cleans up reservations for entities that have been despawned
/// or have had their `GridReserver` component removed.
///
/// This prevents "ghost" reservations from permanently blocking tiles.
fn cleanup_dangling_reservations(
    mut reservations: ResMut<GridReservations>,
    mut removed_reservers: RemovedComponents<GridReserver>,
) {
    // Collect the removed entities into a HashSet for efficient O(1) lookups.
    // In Bevy 0.16, you must use the .read() method to get an iterator.
    let removed_set: HashSet<Entity> = removed_reservers.read().collect();

    // No need to run if no components were removed this frame.
    if removed_set.is_empty() {
        return;
    }

    // Create a temporary Vec of cells to clear. We do this to avoid borrowing `reservations`
    // mutably while iterating over it.
    let cells_to_clear: Vec<IVec2> = reservations
        .0
        .iter()
        // Find all reservations where the entity ID is in our set of removed entities.
        .filter(|(_, &entity)| removed_set.contains(&entity))
        .map(|(&cell, _)| cell)
        .collect();

    for cell in cells_to_clear {
        reservations.0.remove(&cell);
    }
}
</grid_reservation.rs>

<main.rs>
use bevy::prelude::*;

//link our modules to our project

pub mod assets;
pub mod audio;
pub mod border;
pub mod collate_src;
pub mod collider;
pub mod components;
pub mod custom_window;
pub mod debug;
pub mod diagnostics;
pub mod enemy;
pub mod explosion;
pub mod game;
pub mod grid_movement;
pub mod grid_reservation;
pub mod map;
pub mod player;
pub mod projectile;
pub mod random;
pub mod resolution;
pub mod score;
pub mod tilemap;
pub mod title;
pub mod ui_scaling;

fn main() {
    App::new()
        .add_plugins((custom_window::CustomWindowPlugin, game::GamePlugin))
        .run();
}
</main.rs>

<map.rs>
use crate::components::GameState;
use bevy::prelude::*;

#[derive(Resource)]
struct MapHandle(Handle<Image>);

#[derive(Resource)]
pub struct MapData {
    pub width: u32,
    pub height: u32,
    pub is_wall: Vec<bool>,
}

pub struct MapPlugin;

impl Plugin for MapPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(OnEnter(GameState::Loading), load_map)
            .add_systems(Update, process_map.run_if(resource_exists::<MapHandle>));
    }
}

fn load_map(mut commands: Commands, asset_server: Res<AssetServer>) {
    let handle: Handle<Image> = asset_server.load("maps/0.png");
    commands.insert_resource(MapHandle(handle));
}

fn process_map(mut commands: Commands, map_handle: Res<MapHandle>, images: Res<Assets<Image>>) {
    if let Some(image) = images.get(&map_handle.0) {
        let width = image.size().x as u32;
        let height = image.size().y as u32;
        let mut is_wall = vec![false; (width * height) as usize];

        if let Some(data) = &image.data {
            for y in 0..height {
                for x in 0..width {
                    let idx = ((y * width + x) * 4) as usize;
                    // Ensure we don't go out of bounds
                    if idx + 2 < data.len() {
                        let r = data[idx] as f32 / 255.0;
                        let g = data[idx + 1] as f32 / 255.0;
                        let b = data[idx + 2] as f32 / 255.0;
                        // extend the wall on top and right edges to allow for scrolling clamp issue
                        is_wall[(y * width + x) as usize] = r > 0.0
                            || g > 0.0
                            || b > 0.0
                            || y < 2
                            || x >= width - 2
                            || x == 0
                            || y == 0
                            || y == height - 1;
                    }
                }
            }
        }

        commands.insert_resource(MapData {
            width,
            height,
            is_wall,
        });
        commands.remove_resource::<MapHandle>();
    }
}
</map.rs>

<player.rs>
// player.rs

//! Manages the player entity, including its creation, input handling, actions,
//! and the camera scrolling logic that follows it.

use bevy::prelude::*;

use crate::assets::GameAssets;
use crate::audio;
use crate::collider::Collider;
use crate::components::{GameEntity, GameState};
use crate::grid_movement::{is_wall, GridMover, IntendedDirection, MovementSystems};
use crate::grid_reservation::{GridReservations, GridReserver};
use crate::map::MapData;
use crate::projectile::{Bouncable, Projectile};
use crate::random::{random_colour, random_float};
use crate::tilemap::{
    MapOffset, TileOffset, HALF_HEIGHT, HALF_WIDTH, RENDERED_HEIGHT, RENDERED_WIDTH, TILE_SIZE,
};
use bevy_rand::prelude::{GlobalEntropy, WyRand};

/// A plugin responsible for managing player-related logic.
///
/// This plugin registers systems for player spawning, input handling (movement and shooting),
/// and camera scrolling, ensuring they run only when the game is in the `Playing` state.
pub struct PlayerPlugin;

impl Plugin for PlayerPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(OnEnter(GameState::Playing), spawn_player)
            .add_systems(
                Update,
                (
                    // Player input systems are grouped in the `Input` set from MovementSystems.
                    handle_player_input.in_set(MovementSystems::Input),
                    handle_shoot.in_set(MovementSystems::Input),
                    // Camera scrolling logic runs after the player's position has been updated.
                    smooth_adjust_scroll.in_set(MovementSystems::AdjustScroll),
                )
                    .run_if(in_state(GameState::Playing)),
            );
    }
}

/// A marker component used to identify the player entity.
#[derive(Component)]
pub struct Player;

/// The base speed multiplier for player and projectile movement.
pub const DEFAULT_PLAYER_SPEED: f32 = 1000.0;

/// Defines the size of the "camera deadzone" in tiles. The camera will not scroll
/// until the player moves beyond this buffer area from the center of the screen.
const BUFFER_TILES: Vec2 = Vec2::new(4.0, 4.0);

/// Constants for controlling the smoothness of the camera follow.
/// BASE_TAU is the base time constant (in seconds) for the exponential lerp when the player is just outside the buffer.
/// TAU_SCALE determines how much the time constant decreases (speed increases) for each additional tile beyond the buffer.
const BASE_TAU: f32 = 4.0;
const BASE_TAU_SCALE: f32 = 1.0;

/// Spawns the player entity at a random, valid (non-wall) location on the map.
///
/// This system runs once when entering the `GameState::Playing` state. It also
/// calculates the initial map and tile offsets to center the camera on the
/// newly spawned player.
fn spawn_player(
    mut commands: Commands,
    game_assets: Res<GameAssets>,
    mut rng: GlobalEntropy<WyRand>,
    map_data: Res<MapData>,
    mut map_offset: ResMut<MapOffset>,
    mut tile_offset: ResMut<TileOffset>,
    mut reservations: ResMut<GridReservations>,
) {
    let width = map_data.width as i32;
    let height = map_data.height as i32;
    let mut mx: i32;
    let mut my: i32;

    // Loop until a valid, non-wall starting position is found.
    loop {
        mx = (random_float(&mut rng) * width as f32) as i32;
        my = (random_float(&mut rng) * height as f32) as i32;
        let flipped_y = (height - 1 - my) as u32; // Map data is stored with Y-axis flipped.
        let idx = (flipped_y * map_data.width + mx as u32) as usize;
        if let Some(&is_wall) = map_data.is_wall.get(idx) {
            if !is_wall {
                break; // Found a valid spot.
            }
        }
    }

    // Calculate the initial integer-based map offset to position the player near the center of the view.
    // This is clamped to ensure the view doesn't go outside the map boundaries.
    let ox =
        ((mx as f32 - HALF_WIDTH).floor() as i32).clamp(0, (width - RENDERED_WIDTH as i32).max(0));
    let oy = ((my as f32 - HALF_HEIGHT).floor() as i32)
        .clamp(0, (height - RENDERED_HEIGHT as i32).max(0));
    map_offset.0 = IVec2::new(ox, oy);

    // Calculate the fractional (sub-tile) offset needed for smooth scrolling.
    let frac_x = mx as f32 - ox as f32 - HALF_WIDTH;
    let frac_y = my as f32 - oy as f32 - HALF_HEIGHT;
    tile_offset.0 = Vec2::new(-frac_x * TILE_SIZE, -frac_y * TILE_SIZE);

    // Spawn the player entity with all its necessary components.
    let player_entity = commands
        .spawn((
            Sprite {
                color: Color::WHITE,
                image: game_assets.player_texture.clone(),
                ..default()
            },
            Transform::from_xyz(0.0, 0.0, 1.0), // Initial position is centered, adjusted by GridMover.
            Player,
            GridMover {
                grid_pos: IVec2::new(mx, my),
                direction: IVec2::ZERO,
                progress: 0.0,
                speed: DEFAULT_PLAYER_SPEED,
            },
            IntendedDirection(IVec2::ZERO),
            GameEntity, // Marker for cleanup when returning to the title screen.
            Collider {
                size: Vec2::splat(TILE_SIZE * 0.5), // A smaller collider than the tile size.
            },
            GridReserver, // Add the reserver component
        ))
        .id();

    // Make the initial reservation for the player's starting cell.
    reservations.0.insert(IVec2::new(mx, my), player_entity);
}

/// Reads keyboard input (W, A, S, D) to set the player's intended direction of movement.
///
/// This system updates the `IntendedDirection` component, which is then used by the
/// `update_grid_movement` system to control the `GridMover`.
fn handle_player_input(
    keys: Res<ButtonInput<KeyCode>>,
    mut query: Query<&mut IntendedDirection, With<Player>>,
) {
    if let Ok(mut intended) = query.single_mut() {
        let mut dx = 0i32;
        if keys.pressed(KeyCode::KeyA) {
            dx -= 1;
        }
        if keys.pressed(KeyCode::KeyD) {
            dx += 1;
        }
        let mut dy = 0i32;
        if keys.pressed(KeyCode::KeyS) {
            dy -= 1;
        }
        if keys.pressed(KeyCode::KeyW) {
            dy += 1;
        }
        intended.0 = IVec2::new(dx, dy);
    }
}

/// Handles the player's shooting action based on keyboard input.
///
/// When the Space key is pressed, this system spawns a projectile entity.
/// The projectile is spawned one tile ahead of the player in their current
/// intended direction of movement. No projectile is fired if the player is stationary
/// or aiming at a wall.
fn handle_shoot(
    keys: Res<ButtonInput<KeyCode>>,
    mouse: Res<ButtonInput<MouseButton>>,
    mut commands: Commands,
    mut rng: GlobalEntropy<WyRand>,
    game_assets: Res<GameAssets>,
    query: Query<(&GridMover, &IntendedDirection), With<Player>>,
    map_data: Res<MapData>,
) {
    // Check for the shoot button press.
    if keys.just_pressed(KeyCode::Space) || mouse.just_pressed(MouseButton::Left) {
        if let Ok((mover, intended)) = query.single() {
            // Only shoot if the player has a direction.
            if intended.0 != IVec2::ZERO {
                let dir = intended.0;
                let spawn_pos = mover.grid_pos + dir; // Spawn in the next tile over.

                // Prevent spawning a projectile inside a wall.
                if is_wall(spawn_pos, &map_data) {
                    return;
                }
                let color = random_colour(&mut rng, &game_assets);

                // Spawn the projectile entity.
                commands.spawn((
                    Sprite {
                        color,
                        image: game_assets.player_texture.clone(), // Uses player texture for now.
                        ..default()
                    },
                    Transform::from_xyz(0.0, 0.0, 1.0),
                    Projectile,
                    GridMover {
                        grid_pos: spawn_pos,
                        direction: dir,
                        progress: 0.0,
                        speed: mover.speed * 1.5, // projectiles are always 1.5x faster than player
                    },
                    IntendedDirection(dir), // The projectile continues in the player's direction.
                    Bouncable {
                        initial: 3, // if a projectile has bounced at least once, it can now hit the player
                        remaining: 3,
                    }, // Can bounce off walls 3 times.
                    Collider {
                        size: Vec2::splat(TILE_SIZE * 0.5),
                    },
                    GameEntity,
                ));
                // Play the shooting sound effect.
                audio::play(&mut commands, game_assets.shoot_sfx.clone());
            }
        }
    }
}

/// Implements smooth camera scrolling by lerping the map and tile offsets.
///
/// This function uses an exponential lerp to smoothly adjust the view center towards the player's
/// map position when the player is outside the central buffer zone. The lerp strength increases
/// (time constant decreases) as the player gets farther from the center, preventing the player
/// from racing too far offscreen. The view is clamped to the map boundaries.
fn smooth_adjust_scroll(
    query_player: Query<(&Transform, &GridMover), With<Player>>,
    mut map_offset: ResMut<MapOffset>,
    mut tile_offset: ResMut<TileOffset>,
    map_data: Res<MapData>,
    time: Res<Time>,
) {
    // Compute the current view center in map coordinates.
    let mut current_view_center = Vec2::new(
        map_offset.0.x as f32 - tile_offset.0.x / TILE_SIZE + HALF_WIDTH,
        map_offset.0.y as f32 - tile_offset.0.y / TILE_SIZE + HALF_HEIGHT,
    );

    if let Ok((player_tr, grid_mover)) = query_player.single() {
        let player_screen = player_tr.translation.xy();

        // Compute the player's current position in map coordinates.
        let player_map_pos = Vec2::new(
            (player_screen.x - tile_offset.0.x) / TILE_SIZE + map_offset.0.x as f32 + HALF_WIDTH,
            (player_screen.y - tile_offset.0.y) / TILE_SIZE + map_offset.0.y as f32 + HALF_HEIGHT,
        );

        // Adjust TAU_SCALE based on player's speed relative to DEFAULT_PLAYER_SPEED.
        let speed_ratio = grid_mover.speed / DEFAULT_PLAYER_SPEED;
        let dynamic_tau_scale = BASE_TAU_SCALE / speed_ratio.max(0.001); // Prevent division by zero

        // Calculate the desired view center (player position) and interpolate.
        let diff = player_map_pos - current_view_center;
        let abs_diff = diff.abs();
        let half_buf = BUFFER_TILES / 2.0;

        // Initialize t (interpolation factor) to 0.0 (no movement if within buffer).
        let mut t = 0.0;

        // Check if player is outside the buffer zone on either axis.
        if abs_diff.x > half_buf.x || abs_diff.y > half_buf.y {
            // Compute interpolation factor t based on distance beyond buffer.
            let extra = (abs_diff - half_buf).max(Vec2::ZERO);
            let tau = BASE_TAU / (1.0 + extra.length() / dynamic_tau_scale);
            t = 1.0 - (-time.delta_secs() / tau).exp();
        }

        // Use Vec2::lerp to interpolate towards the player's position.
        current_view_center = current_view_center.lerp(player_map_pos, t);

        // Compute the new view left and top edges.
        let mut new_view_left = current_view_center.x - HALF_WIDTH;
        let mut new_view_top = current_view_center.y - HALF_HEIGHT;

        // Clamp to map boundaries.
        let max_left = (map_data.width as f32 - RENDERED_WIDTH as f32).max(0.0);
        let max_top = (map_data.height as f32 - RENDERED_HEIGHT as f32).max(0.0);
        new_view_left = new_view_left.clamp(0.0, max_left);
        new_view_top = new_view_top.clamp(0.0, max_top);

        // Update map_offset and tile_offset for X.
        map_offset.0.x = new_view_left.floor() as i32;
        let frac_x = new_view_left - map_offset.0.x as f32;
        tile_offset.0.x = -frac_x * TILE_SIZE;

        // Update map_offset and tile_offset for Y.
        map_offset.0.y = new_view_top.floor() as i32;
        let frac_y = new_view_top - map_offset.0.y as f32;
        tile_offset.0.y = -frac_y * TILE_SIZE;
    }
}
</player.rs>

<projectile.rs>
use crate::collider::ProjectileCollision;
use crate::components::{EnemyDied, GameState, PlayerDied};
use crate::enemy::Enemy;
use crate::player::Player;
use crate::score::ScoreChanged;
use bevy::prelude::*;

#[derive(Component)]
pub struct Projectile;

#[derive(Component)]
pub struct Bouncable {
    pub initial: u32,   // Tracks the initial number of bounces allowed
    pub remaining: u32, // Tracks the remaining bounces
}

pub struct ProjectilePlugin;

impl Plugin for ProjectilePlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(
            Update,
            handle_projectile_collisions.run_if(in_state(GameState::Playing)),
        );
    }
}

/// Listens for `ProjectileCollision` events and handles the consequences.
fn handle_projectile_collisions(
    mut commands: Commands,
    mut collision_events: EventReader<ProjectileCollision>,
    mut score_events: EventWriter<ScoreChanged>,
    mut player_died_events: EventWriter<PlayerDied>,
    mut enemy_died_events: EventWriter<EnemyDied>,
    // Query to determine if the victim was a Player or an Enemy.
    victim_query: Query<(Has<Player>, Has<Enemy>, &Transform)>,
) {
    for event in collision_events.read() {
        // Despawn the projectile on any confirmed collision.
        commands.entity(event.projectile).despawn();

        // Check what the victim was and react accordingly.
        if let Ok((is_player, is_enemy, transform)) = victim_query.get(event.victim) {
            let pos = transform.translation;
            if is_player {
                commands.entity(event.victim).despawn();

                player_died_events.write(PlayerDied(pos));
                info!("Player was hit by a projectile!");
            } else if is_enemy {
                commands.entity(event.victim).despawn();

                enemy_died_events.write(EnemyDied(pos));
                score_events.write(ScoreChanged);
            }
        }
    }
}
</projectile.rs>

<random.rs>
// src/random.rs

use bevy::prelude::*;
// Import WyRand and the necessary query components from bevy_rand
use bevy_rand::prelude::{EntropyPlugin, GlobalEntropy, WyRand};

use crate::assets::GameAssets;
use rand_core::RngCore;
use std::time::{SystemTime, UNIX_EPOCH};

/// Plugin for handling random number generation with WyRand
#[derive(Debug, Clone, Copy, Default)]
pub struct RandomPlugin;

impl Plugin for RandomPlugin {
    fn build(&self, app: &mut App) {
        let seed = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .expect("Time went backwards")
            .as_nanos() as u64;

        // The `with_seed` function expects a byte array.
        // We convert the u64 seed to a little-endian byte array.
        app.add_plugins(EntropyPlugin::<WyRand>::with_seed(seed.to_le_bytes()));
    }
}

pub fn random_float(rng: &mut GlobalEntropy<WyRand>) -> f32 {
    (rng.next_u32() as f32) / (u32::MAX as f32)
}

/// Returns a random color from the GameAssets palette
pub fn random_colour(rng: &mut GlobalEntropy<WyRand>, game_assets: &Res<GameAssets>) -> Color {
    let palette = &game_assets.palette;
    let index = (random_float(rng) * palette.colors.len() as f32) as usize;
    palette.colors[index]
}
</random.rs>

<resolution.rs>
use bevy::prelude::*;
use bevy::window::{PrimaryWindow, WindowResized};

pub struct ResolutionPlugin;

impl Plugin for ResolutionPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(PreStartup, setup_resolution).add_systems(
            Update,
            (handle_window_resize, update_camera_projection).chain(),
        );
    }
}

// Increasing this value will result in the projection zooming out, showing more of the render area
const MASTER_SCALE: f32 = 4.0;

#[derive(Resource)]
pub struct Resolution {
    // Pixel dimensions of the screen (width, height)
    pub screen_dimensions: Vec2,
    // The ratio of a pixel in our sprites to one on screen
    pub pixel_ratio: f32,
    // Base resolution for scaling (e.g., the design resolution)
    pub base_resolution: Vec2,
    // Decrease to show more onscreen 0..1
    pub zoom: f32,
}

fn setup_resolution(mut commands: Commands, window_query: Query<&Window, With<PrimaryWindow>>) {
    if let Ok(window) = window_query.single() {
        let width = window.resolution.width();
        let height = window.resolution.height();

        commands.insert_resource(Resolution {
            screen_dimensions: Vec2::new(width, height),
            pixel_ratio: window.scale_factor() as f32,
            base_resolution: Vec2::new(800.0, 600.0),
            zoom: 1.0,
        });
    } else {
        error!("No primary window found during resolution setup");
        // Fallback to default resolution
        commands.insert_resource(Resolution {
            screen_dimensions: Vec2::new(800.0, 600.0),
            pixel_ratio: 1.0,
            base_resolution: Vec2::new(800.0, 600.0),
            zoom: 1.0,
        });
    }
}

fn handle_window_resize(
    mut resize_events: EventReader<WindowResized>,
    mut resolution: ResMut<Resolution>,
    // Query for the Entity and the Window component of the primary window
    window_query: Query<(Entity, &Window), With<PrimaryWindow>>,
) {
    // Get the entity and component for the primary window
    if let Ok((primary_window_entity, primary_window)) = window_query.single() {
        for event in resize_events.read() {
            // Compare the event's entity with the primary window's entity
            if event.window == primary_window_entity {
                resolution.screen_dimensions = Vec2::new(event.width, event.height);
                resolution.pixel_ratio = primary_window.scale_factor() as f32;
                info!("Window resized to {}x{}", event.width, event.height);
            }
        }
    }
}

fn update_camera_projection(
    resolution: Res<Resolution>,
    mut query: Query<&mut Projection, With<Camera2d>>,
) {
    if resolution.is_changed() {
        for mut projection in query.iter_mut() {
            if let Projection::Orthographic(ref mut ortho) = &mut *projection {
                let scale_x = resolution.screen_dimensions.x / resolution.base_resolution.x;
                let scale_y = resolution.screen_dimensions.y / resolution.base_resolution.y;
                // Use the smaller scale to maintain aspect ratio and avoid stretching
                let scale = scale_x.min(scale_y) * resolution.pixel_ratio;

                ortho.scale = (MASTER_SCALE * resolution.zoom) * 1.0 / scale;
                info!("Updated camera projection scale: {}", ortho.scale);
            }
        }
    }
}
</resolution.rs>

<score.rs>
// score.rs
use bevy::prelude::*;

use crate::assets::GameAssets;
use crate::components::{GameEntity, GameState};

pub struct ScorePlugin;

impl Plugin for ScorePlugin {
    fn build(&self, app: &mut App) {
        app.add_event::<ScoreChanged>()
            .add_systems(OnEnter(GameState::Playing), setup_score)
            .add_systems(
                Update,
                (update_score, update_score_display)
                    .chain()
                    .run_if(in_state(GameState::Playing)),
            );
    }
}

#[derive(Resource)]
pub struct Score {
    pub value: u32,
}

#[derive(Event)]
pub struct ScoreChanged;

#[derive(Component)]
struct ScoreText;

fn setup_score(mut commands: Commands, game_assets: Res<GameAssets>) {
    commands.insert_resource(Score { value: 0 });

    let root = commands
        .spawn((
            Node {
                position_type: PositionType::Absolute,
                top: Val::Px(10.0),
                width: Val::Percent(100.0),
                height: Val::Px(60.0),
                flex_direction: FlexDirection::Column,
                justify_content: JustifyContent::FlexStart,
                align_items: AlignItems::Center,
                ..default()
            },
            BackgroundColor(Color::NONE),
            GameEntity,
        ))
        .id();

    commands.entity(root).with_children(|parent| {
        parent.spawn((
            Text::new("0000".to_string()),
            TextFont {
                font: game_assets.font.clone(),
                font_size: 16.0,
                ..default()
            },
            TextColor(game_assets.palette.colors[3]),
            TextLayout::new_with_justify(JustifyText::Center),
            ScoreText,
        ));
    });
}

fn update_score(mut score: ResMut<Score>, mut events: EventReader<ScoreChanged>) {
    for _ in events.read() {
        score.value += 1;
        if score.value > 9999 {
            score.value = 9999;
        }
    }
}

fn update_score_display(score: Res<Score>, mut query: Query<&mut Text, With<ScoreText>>) {
    if score.is_changed() {
        if let Ok(mut text) = query.single_mut() {
            text.0 = format!("{:04}", score.value);
        }
    }
}
</score.rs>

<tilemap.rs>
// tilemap.rs
use bevy::prelude::*;
use bevy::sprite::Sprite;
use bevy_rand::prelude::{GlobalEntropy, WyRand};

use crate::assets::GameAssets;
use crate::components::{GameEntity, GameState};
use crate::map::MapData;
use crate::random::random_colour;

pub const TILE_SIZE: f32 = 64.0;
pub const RENDERED_WIDTH: usize = 32;
pub const RENDERED_HEIGHT: usize = 26;
pub const HALF_WIDTH: f32 = (RENDERED_WIDTH as f32 - 1.0) / 2.0;
pub const HALF_HEIGHT: f32 = (RENDERED_HEIGHT as f32 - 1.0) / 2.0;
/// Defines the size of one side of a checkerboard square, in tiles.
pub const CHECKER_SIZE: u32 = 4;

#[derive(Resource)]
pub struct MapOffset(pub IVec2);

#[derive(Resource)]
pub struct TileOffset(pub Vec2);

/// A resource to hold the two darkened, randomized colors for the floor pattern.
#[derive(Resource)]
pub struct FloorPalette {
    pub color_a: Color,
    pub color_b: Color,
}

#[derive(Component)]
pub struct Tile {
    pub grid_pos: IVec2,
}

#[derive(Component)]
pub struct BasePosition(pub Vec2);

pub struct TilemapPlugin;

impl Plugin for TilemapPlugin {
    fn build(&self, app: &mut App) {
        app.insert_resource(MapOffset(IVec2::ZERO))
            .insert_resource(TileOffset(Vec2::ZERO))
            .add_systems(
                OnEnter(GameState::Playing),
                (
                    setup_initial_offset,
                    setup_floor_palette, // Create the random palette
                    spawn_tilemap,
                )
                    .chain(),
            )
            .add_systems(
                Update,
                ((update_tile_positions, update_tile_colors)
                    .run_if(resource_changed::<MapOffset>.or(resource_changed::<TileOffset>)),)
                    .chain()
                    .run_if(in_state(GameState::Playing)),
            );
    }
}

/// A new system that runs once to create and store the floor palette.
/// It picks two random colors, darkens them, and inserts them as a resource.
fn setup_floor_palette(
    mut commands: Commands,
    game_assets: Res<GameAssets>,
    mut rng: GlobalEntropy<WyRand>,
) {
    // pick 2 random different colours from our palette
    let mut color_a = random_colour(&mut rng, &game_assets);
    let mut color_b = random_colour(&mut rng, &game_assets);
    while color_a == color_b {
        color_b = random_colour(&mut rng, &game_assets);
    }

    // darken them
    let darken_factor = 0.25;
    color_a = darken(color_a, darken_factor);
    color_b = darken(color_b, darken_factor);

    // and insert them into a resource
    commands.insert_resource(FloorPalette {
        color_a: color_a,
        color_b: color_b,
    });
}

fn darken(c: Color, darken_factor: f32) -> Color {
    match c {
        Color::Srgba(mut srgba) => {
            srgba.red *= darken_factor;
            srgba.green *= darken_factor;
            srgba.blue *= darken_factor;
            Color::Srgba(srgba)
        }
        _ => c,
    }
}

// center map in viewport
fn setup_initial_offset(map_data: Res<MapData>, mut map_offset: ResMut<MapOffset>) {
    let view_w = RENDERED_WIDTH as i32;
    let view_h = RENDERED_HEIGHT as i32;
    let map_w = map_data.width as i32;
    let map_h = map_data.height as i32;
    map_offset.0.x = ((map_w - view_w) / 2).max(0);
    map_offset.0.y = ((map_h - view_h) / 2).max(0);
}

// spawns the viewable section of the tilemap, with each visible tile being an individual sprite entity
fn spawn_tilemap(
    mut commands: Commands,
    game_assets: Res<GameAssets>,
    map_data: Res<MapData>,
    map_offset: Res<MapOffset>,
    floor_palette: Res<FloorPalette>, // Get the newly created floor palette
) {
    let wall_texture = game_assets.wall_texture.clone();

    for gx in 0..RENDERED_WIDTH {
        for gy in 0..RENDERED_HEIGHT {
            let base_x = (gx as f32 - HALF_WIDTH) * TILE_SIZE;
            let base_y = (gy as f32 - HALF_HEIGHT) * TILE_SIZE;
            let base_pos = Vec2::new(base_x, base_y);

            let grid_pos = IVec2::new(gx as i32, gy as i32);
            let map_pos = grid_pos + map_offset.0;
            // Pass the palette to the color logic function
            let color = get_tile_color(map_pos, &game_assets, &map_data, &floor_palette);

            commands.spawn((
                Sprite {
                    image: wall_texture.clone(),
                    color,
                    ..Default::default()
                },
                Transform::from_xyz(base_x, base_y, 0.0),
                Tile { grid_pos },
                BasePosition(base_pos),
                GameEntity,
            ));
        }
    }
}

fn update_tile_positions(
    tile_offset: Res<TileOffset>,
    mut query: Query<(&BasePosition, &mut Transform), With<Tile>>,
) {
    for (base_pos, mut transform) in query.iter_mut() {
        transform.translation = Vec3::new(
            base_pos.0.x + tile_offset.0.x,
            base_pos.0.y + tile_offset.0.y,
            0.0,
        );
    }
}

/// Updated to determine tile color based on walls and the new checkerboard floor.
fn get_tile_color(
    map_pos: IVec2,
    game_assets: &GameAssets,
    map_data: &MapData,
    floor_palette: &FloorPalette,
) -> Color {
    // First, check if the position is within the map's boundaries.
    // If not, return a transparent color to avoid drawing outside the map area.
    if map_pos.x < 0
        || map_pos.y < 0
        || map_pos.x >= map_data.width as i32
        || map_pos.y >= map_data.height as i32
    {
        return Color::NONE;
    }

    // Determine if the current tile is a wall.
    let x = map_pos.x as u32;
    let y = map_pos.y as u32;
    let flipped_y = map_data.height - 1 - y;
    let idx = (flipped_y * map_data.width + x) as usize;
    let is_wall = map_data.is_wall.get(idx).copied().unwrap_or(false);

    if is_wall {
        // It's a wall, so calculate its color based on its position.
        let index =
            ((map_pos.x.abs() + map_pos.y.abs()) as usize) % game_assets.palette.colors.len();
        game_assets.palette.colors[index]
    } else {
        // It's a floor tile, so apply the checkerboard pattern.
        // Use Euclidean division to handle potential negative coordinates gracefully.
        let checker_x = map_pos.x.div_euclid(CHECKER_SIZE as i32);
        let checker_y = map_pos.y.div_euclid(CHECKER_SIZE as i32);
        if (checker_x + checker_y) % 2 == 0 {
            floor_palette.color_a
        } else {
            floor_palette.color_b
        }
    }
}

/// Updated to pass the FloorPalette resource to the color logic.
fn update_tile_colors(
    map_offset: Res<MapOffset>,
    game_assets: Res<GameAssets>,
    map_data: Res<MapData>,
    floor_palette: Res<FloorPalette>, // Get the floor palette
    mut query: Query<(&Tile, &mut Sprite)>,
) {
    for (tile, mut sprite) in query.iter_mut() {
        let map_pos = map_offset.0 + tile.grid_pos;
        // Pass the palette to the color logic function
        sprite.color = get_tile_color(map_pos, &game_assets, &map_data, &floor_palette);
    }
}
</tilemap.rs>

<title.rs>
use crate::assets::GameAssets;
use crate::components::{GameEntity, GameState};
use bevy::prelude::*;
use bevy::state::app::AppExtStates;

pub struct TitlePlugin;

impl Plugin for TitlePlugin {
    fn build(&self, app: &mut App) {
        app.init_state::<GameState>()
            .add_systems(OnEnter(GameState::Title), (spawn_title, cleanup_game))
            .add_systems(OnExit(GameState::Title), despawn_title)
            .add_systems(
                Update,
                handle_title_input.run_if(in_state(GameState::Title)),
            );
    }
}

#[derive(Component)]
struct TitleText;

fn spawn_title(mut commands: Commands, game_assets: Res<GameAssets>) {
    let root = commands
        .spawn((
            Node {
                position_type: PositionType::Absolute,
                width: Val::Percent(100.0),
                height: Val::Percent(100.0),
                flex_direction: FlexDirection::Column,
                justify_content: JustifyContent::Center,
                align_items: AlignItems::Center,
                ..default()
            },
            BackgroundColor(Color::NONE),
            TitleText,
        ))
        .id();

    commands.entity(root).with_children(|parent| {
        parent
            .spawn(Node {
                flex_direction: FlexDirection::Row,
                align_items: AlignItems::Start,
                ..default()
            })
            .with_children(|title_row| {
                title_row.spawn((
                    Text::new("GRIDMAN"),
                    TextFont {
                        font: game_assets.font.clone(),
                        font_size: 40.0,
                        ..default()
                    },
                    TextColor(game_assets.palette.colors[3]),
                    TextLayout::new_with_justify(JustifyText::Center),
                ));

                title_row.spawn((
                    Text::new("ECS"),
                    TextFont {
                        font: game_assets.font.clone(),
                        font_size: 12.0, // Smaller font size for superscript
                        ..default()
                    },
                    TextColor(game_assets.palette.colors[2]),
                    TextLayout::new_with_justify(JustifyText::Left),
                ));
            });

        parent.spawn((
            Text::new("FIRE TO PLAY"),
            TextFont {
                font: game_assets.font.clone(),
                font_size: 20.0,
                ..default()
            },
            TextColor(game_assets.palette.colors[4]),
            TextLayout::new_with_justify(JustifyText::Center),
        ));
    });
}

fn despawn_title(mut commands: Commands, query: Query<Entity, With<TitleText>>) {
    for entity in query.iter() {
        commands.entity(entity).despawn();
    }
}

/// Only runs if displaying title screen
fn handle_title_input(
    mut next_state: ResMut<NextState<GameState>>,
    keys: Res<ButtonInput<KeyCode>>,
    mouse: Res<ButtonInput<MouseButton>>,
) {
    if keys.just_pressed(KeyCode::Space) || mouse.just_pressed(MouseButton::Left) {
        next_state.set(GameState::Playing);
    }
}

fn cleanup_game(mut commands: Commands, query: Query<Entity, With<GameEntity>>) {
    info!("Cleaning up game entities");
    for entity in query.iter() {
        commands.entity(entity).despawn();
    }
}
</title.rs>

<ui_scaling.rs>
use crate::resolution::Resolution;
use bevy::prelude::*;
use bevy::ui::UiScale;
use bevy::window::{PrimaryWindow, WindowResized};

pub struct UiScalingPlugin;

impl Plugin for UiScalingPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Startup, setup_ui_scale)
            .add_systems(Update, update_ui_scale_on_resize);
    }
}

fn setup_ui_scale(
    mut commands: Commands,
    window_query: Query<&Window, With<PrimaryWindow>>,
    resolution: Res<Resolution>,
) {
    let initial_scale = if let Ok(window) = window_query.single() {
        window.resolution.height() / resolution.base_resolution.y
    } else {
        1.0
    };
    commands.insert_resource(UiScale(initial_scale));
}

fn update_ui_scale_on_resize(
    mut resize_events: EventReader<WindowResized>,
    mut ui_scale: ResMut<UiScale>,
    window_query: Query<&Window, With<PrimaryWindow>>,
    resolution: Res<Resolution>,
) {
    for _event in resize_events.read() {
        if let Ok(primary_window) = window_query.single() {
            let current_height = primary_window.resolution.height();
            ui_scale.0 = current_height / resolution.base_resolution.y;
        }
    }
}
</ui_scaling.rs>

<task rules>
As usual, we require an ECS-first, performant, and elegant solution that perfectly solves our problem while adhering to Bevy's best practices for modularity, efficiency, and maintainability.

We are using Bevy 0.16.1, so avoid all deprecated APIs or fields (e.g., use .delta_secs() instead of .delta_seconds()). Refer to the existing codebase for examples of correct syntax and patterns when in doubt, and ensure compatibility with Bevy's current features.

Before writing any code, think step-by-step through your design strategy out loud: outline the problem requirements, brainstorm multiple architectural options (e.g., different component/system/query designs), evaluate their trade-offs in terms of performance, simplicity, and extensibility, and justify your selection of the optimal approach.

If applicable, use the code_execution tool to prototype or verify non-Bevy-specific logic (e.g., file I/O, string manipulation) during your reasoning phase. Focus on edge cases or complex logic that benefits from isolated testing, but avoid attempting to execute Bevy-specific ECS or rendering functionality.

Professionally comment all new code and retain all existing comments.

Output all changed or new files in full, each in its own dedicated codebox. Do not output unchanged files or partial diffs—provide complete, compilable files.

After outputting all files, provide a concise summary (outside of codeboxes) that recaps the key changes, evaluates their merits (e.g., how they improve performance, readability, or solve edge cases), and suggests any potential future improvements.
</task rules>
<task>
 
</task>
