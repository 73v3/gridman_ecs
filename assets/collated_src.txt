<assets.rs>
// assets.rs
use crate::components::GameState;
use bevy::audio::AudioSource;
use bevy::prelude::*;

pub struct AssetsPlugin;

impl Plugin for AssetsPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(OnEnter(GameState::Loading), load_assets);
    }
}

#[derive(Resource, Clone)]
pub struct Palette {
    pub colors: Vec<Color>,
}

#[derive(Resource)]
pub struct GameAssets {
    pub wall_texture: Handle<Image>,
    pub font: Handle<Font>,
    pub shoot_sfx: Handle<AudioSource>,
    pub palette: Palette,
}

fn load_assets(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    mut next_state: ResMut<NextState<GameState>>,
) {
    let palette = Palette {
        // https://lospec.com/palette-list/gilt-8 by tomicit0
        colors: vec![
            Color::srgb(0.631, 0.224, 0.333),
            Color::srgb(0.761, 0.431, 0.522),
            Color::srgb(0.949, 0.729, 0.800),
            Color::srgb(1.000, 0.949, 0.918),
            Color::srgb(0.984, 0.906, 0.412),
            Color::srgb(0.894, 0.725, 0.169),
            Color::srgb(0.769, 0.416, 0.176),
            Color::srgb(0.506, 0.173, 0.137),
        ],
    };

    commands.insert_resource(GameAssets {
        wall_texture: asset_server.load("textures/wall.png"),
        font: asset_server.load("fonts/press_start_2p/PressStart2P-Regular.ttf"),
        shoot_sfx: asset_server.load("sfx/shoot.wav"),
        palette,
    });
    next_state.set(GameState::Title);
}
</assets.rs>

<audio.rs>
// audio.rs
use bevy::audio::{AudioPlayer, PlaybackSettings, Volume};
use bevy::prelude::*;

pub struct AudioPlugin;

impl Plugin for AudioPlugin {
    fn build(&self, _app: &mut App) {
        // No additional setup needed, as AudioPlugin is included in DefaultPlugins
    }
}

/// Plays a sound effect by spawning an entity that will despawn automatically after playback.
/// This is efficient for one-shot SFX and handles cleanup to avoid entity buildup.
pub fn play(commands: &mut Commands, audio: Handle<AudioSource>) {
    commands.spawn((AudioPlayer::new(audio), PlaybackSettings::DESPAWN));
}

pub fn play_with_volume(commands: &mut Commands, audio: Handle<AudioSource>, volume: f32) {
    commands.spawn((
        AudioPlayer::new(audio),
        PlaybackSettings {
            volume: Volume::Linear(volume),
            ..PlaybackSettings::DESPAWN
        },
    ));
}
</audio.rs>

<components.rs>
use bevy::prelude::*;

#[derive(Clone, Copy, Default, Eq, PartialEq, Hash, States, Debug)]
pub enum GameState {
    #[default]
    Loading,
    Title,
    Playing,
}

#[derive(Component)]
pub struct Dead;

#[derive(Component)]
pub struct GameEntity;

#[derive(Component)]
pub struct Velocity {
    pub velocity: Vec2,
}

#[derive(Event)]
pub struct PlayerDied;

#[derive(Resource)]
pub struct GameSpeed {
    pub value: f32,
}

pub struct ComponentsPlugin;

impl Plugin for ComponentsPlugin {
    fn build(&self, app: &mut App) {
        app.insert_resource(GameSpeed { value: 1.0 }).add_systems(
            Update,
            (update_velocity)
                .chain()
                .run_if(in_state(GameState::Playing)),
        );
    }
}

pub fn update_velocity(mut query: Query<(&Velocity, &mut Transform)>, time: Res<Time>) {
    for (velocity, mut transform) in query.iter_mut() {
        transform.translation.x += velocity.velocity.x * time.delta_secs();
        transform.translation.y += velocity.velocity.y * time.delta_secs();
    }
}
</components.rs>

<custom_window.rs>
// custom_window_plugin.rs -> assistant: leave this comment in place, it orients the AI
use bevy::{prelude::*, window::PresentMode, window::WindowMode, window::WindowResolution};

const GAME_TITLE: &str = "Gridman ECS";
const BACKGROUND_COLOR: Color = Color::srgb(0.1, 0.1, 0.1);

pub struct CustomWindowPlugin;

impl Plugin for CustomWindowPlugin {
    fn build(&self, app: &mut App) {
        app.insert_resource(ClearColor(BACKGROUND_COLOR))
            .add_plugins(
                DefaultPlugins
                    .set(bevy::window::WindowPlugin {
                        primary_window: Some(Window {
                            title: GAME_TITLE.to_string(),
                            present_mode: PresentMode::AutoVsync,
                            mode: WindowMode::Windowed,
                            position: WindowPosition::Centered(MonitorSelection::Primary),
                            resolution: WindowResolution::new(800.0, 600.0),
                            ..default()
                        }),
                        ..default()
                    })
                    .set(ImagePlugin::default_nearest()),
            )
            .add_systems(Update, close_on_esc);
    }
}

pub fn close_on_esc(
    mut commands: Commands,
    focused_windows: Query<(Entity, &Window)>,
    input: Res<ButtonInput<KeyCode>>,
) {
    for (window, focus) in focused_windows.iter() {
        if !focus.focused {
            continue;
        }

        if input.just_pressed(KeyCode::Escape) {
            commands.entity(window).despawn();
        }
    }
}
</custom_window.rs>

<debug.rs>
use crate::components::GameState;
use bevy::prelude::*;

pub struct DebugPlugin;

impl Plugin for DebugPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, test_clear.run_if(in_state(GameState::Playing)));
    }
}

fn test_clear(keys: Res<ButtonInput<KeyCode>>) {
    if keys.just_pressed(KeyCode::End) {
        info!("END pressed");
    }
}
</debug.rs>

<game.rs>
use bevy::prelude::*;

use crate::assets;
use crate::audio;
use crate::collate_src;
use crate::components;
use crate::debug;
use crate::random;
use crate::resolution;
use crate::score;
use crate::tilemap;
use crate::title;
use crate::ui_scaling;
pub struct GamePlugin;

impl Plugin for GamePlugin {
    fn build(&self, app: &mut App) {
        app.add_plugins((
            collate_src::CollateSrcPlugin,
            components::ComponentsPlugin,
            resolution::ResolutionPlugin,
            random::RandomPlugin,
            title::TitlePlugin,
            assets::AssetsPlugin,
            score::ScorePlugin,
            audio::AudioPlugin,
            debug::DebugPlugin,
            ui_scaling::UiScalingPlugin,
            tilemap::TilemapPlugin,
        ))
        .add_systems(Startup, setup_scene);
    }
}
fn setup_scene(mut commands: Commands) {
    commands.spawn(Camera2d::default());
}
</game.rs>

<main.rs>
use bevy::prelude::*;

//link our modules to our project

pub mod assets;
pub mod audio;
pub mod collate_src;
pub mod components;
pub mod custom_window;
pub mod debug;
pub mod game;
pub mod random;
pub mod resolution;
pub mod score;
pub mod tilemap;
pub mod title;
pub mod ui_scaling;

fn main() {
    App::new()
        .add_plugins((custom_window::CustomWindowPlugin, game::GamePlugin))
        .run();
}
</main.rs>

<random.rs>
// src/random.rs

use bevy::prelude::*;
// Import WyRand and the necessary query components from bevy_rand
use bevy_rand::prelude::{EntropyPlugin, GlobalEntropy, WyRand};

use crate::assets::GameAssets;
use rand_core::RngCore;
use std::time::{SystemTime, UNIX_EPOCH};

/// Plugin for handling random number generation with WyRand
#[derive(Debug, Clone, Copy, Default)]
pub struct RandomPlugin;

impl Plugin for RandomPlugin {
    fn build(&self, app: &mut App) {
        let seed = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .expect("Time went backwards")
            .as_nanos() as u64;

        // The `with_seed` function expects a byte array.
        // We convert the u64 seed to a little-endian byte array.
        app.add_plugins(EntropyPlugin::<WyRand>::with_seed(seed.to_le_bytes()));
    }
}

pub fn random_float(rng: &mut GlobalEntropy<WyRand>) -> f32 {
    (rng.next_u32() as f32) / (u32::MAX as f32)
}

/// Returns a random color from the GameAssets palette
pub fn random_colour(rng: &mut GlobalEntropy<WyRand>, game_assets: &Res<GameAssets>) -> Color {
    let palette = &game_assets.palette;
    let index = (random_float(rng) * palette.colors.len() as f32) as usize;
    palette.colors[index]
}
</random.rs>

<resolution.rs>
use bevy::prelude::*;
use bevy::window::{PrimaryWindow, WindowResized};

pub struct ResolutionPlugin;

impl Plugin for ResolutionPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(PreStartup, setup_resolution).add_systems(
            Update,
            (handle_window_resize, update_camera_projection).chain(),
        );
    }
}

#[derive(Resource)]
pub struct Resolution {
    // Pixel dimensions of the screen (width, height)
    pub screen_dimensions: Vec2,
    // The ratio of a pixel in our sprites to one on screen
    pub pixel_ratio: f32,
    // Base resolution for scaling (e.g., the design resolution)
    pub base_resolution: Vec2,
}

fn setup_resolution(mut commands: Commands, window_query: Query<&Window, With<PrimaryWindow>>) {
    if let Ok(window) = window_query.single() {
        let width = window.resolution.width();
        let height = window.resolution.height();

        commands.insert_resource(Resolution {
            screen_dimensions: Vec2::new(width, height),
            pixel_ratio: window.scale_factor() as f32,
            base_resolution: Vec2::new(800.0, 600.0), // Design resolution
        });
    } else {
        error!("No primary window found during resolution setup");
        // Fallback to default resolution
        commands.insert_resource(Resolution {
            screen_dimensions: Vec2::new(800.0, 600.0),
            pixel_ratio: 1.0,
            base_resolution: Vec2::new(800.0, 600.0),
        });
    }
}

fn handle_window_resize(
    mut resize_events: EventReader<WindowResized>,
    mut resolution: ResMut<Resolution>,
    // Query for the Entity and the Window component of the primary window
    window_query: Query<(Entity, &Window), With<PrimaryWindow>>,
) {
    // Get the entity and component for the primary window
    if let Ok((primary_window_entity, primary_window)) = window_query.single() {
        for event in resize_events.read() {
            // Compare the event's entity with the primary window's entity
            if event.window == primary_window_entity {
                resolution.screen_dimensions = Vec2::new(event.width, event.height);
                resolution.pixel_ratio = primary_window.scale_factor() as f32;
                info!("Window resized to {}x{}", event.width, event.height);
            }
        }
    }
}

fn update_camera_projection(
    resolution: Res<Resolution>,
    mut query: Query<&mut Projection, With<Camera2d>>,
) {
    if resolution.is_changed() {
        for mut projection in query.iter_mut() {
            if let Projection::Orthographic(ref mut ortho) = &mut *projection {
                let scale_x = resolution.screen_dimensions.x / resolution.base_resolution.x;
                let scale_y = resolution.screen_dimensions.y / resolution.base_resolution.y;
                // Use the smaller scale to maintain aspect ratio and avoid stretching
                let scale = scale_x.min(scale_y) * resolution.pixel_ratio;

                ortho.scale = 1.0 / scale;
                info!("Updated camera projection scale: {}", ortho.scale);
            }
        }
    }
}
</resolution.rs>

<score.rs>
// score.rs
use bevy::prelude::*;

use crate::assets::GameAssets;
use crate::components::{GameEntity, GameState};

pub struct ScorePlugin;

impl Plugin for ScorePlugin {
    fn build(&self, app: &mut App) {
        app.add_event::<ScoreChanged>()
            .add_systems(OnEnter(GameState::Playing), setup_score)
            .add_systems(
                Update,
                (update_score, update_score_display)
                    .chain()
                    .run_if(in_state(GameState::Playing)),
            );
    }
}

#[derive(Resource)]
pub struct Score {
    pub value: u32,
}

#[derive(Event)]
pub struct ScoreChanged;

#[derive(Component)]
struct ScoreText;

fn setup_score(mut commands: Commands, game_assets: Res<GameAssets>) {
    commands.insert_resource(Score { value: 0 });

    let root = commands
        .spawn((
            Node {
                position_type: PositionType::Absolute,
                top: Val::Px(10.0),
                width: Val::Percent(100.0),
                height: Val::Px(60.0),
                flex_direction: FlexDirection::Column,
                justify_content: JustifyContent::FlexStart,
                align_items: AlignItems::Center,
                ..default()
            },
            BackgroundColor(Color::NONE),
            GameEntity,
        ))
        .id();

    commands.entity(root).with_children(|parent| {
        parent.spawn((
            Text::new("0000".to_string()),
            TextFont {
                font: game_assets.font.clone(),
                font_size: 16.0,
                ..default()
            },
            TextColor(game_assets.palette.colors[3]),
            TextLayout::new_with_justify(JustifyText::Center),
            ScoreText,
        ));
    });
}

fn update_score(mut score: ResMut<Score>, mut events: EventReader<ScoreChanged>) {
    for _ in events.read() {
        score.value += 1;
        if score.value > 9999 {
            score.value = 9999;
        }
    }
}

fn update_score_display(score: Res<Score>, mut query: Query<&mut Text, With<ScoreText>>) {
    if score.is_changed() {
        if let Ok(mut text) = query.single_mut() {
            text.0 = format!("{:04}", score.value);
        }
    }
}
</score.rs>

<tilemap.rs>
// tilemap.rs
use bevy::prelude::*;
use bevy::sprite::Sprite;

use crate::assets::GameAssets;
use crate::components::{GameEntity, GameState};

const TILE_SIZE: f32 = 64.0;
const RENDERED_WIDTH: usize = 14;
const RENDERED_HEIGHT: usize = 11;
const HALF_WIDTH: f32 = (RENDERED_WIDTH as f32 - 1.0) / 2.0;
const HALF_HEIGHT: f32 = (RENDERED_HEIGHT as f32 - 1.0) / 2.0;

#[derive(Resource)]
pub struct MapOffset(pub IVec2);

#[derive(Resource)]
pub struct TileOffset(pub Vec2);

#[derive(Component)]
pub struct Tile {
    pub grid_pos: IVec2,
}

#[derive(Component)]
pub struct BasePosition(pub Vec2);

pub struct TilemapPlugin;

impl Plugin for TilemapPlugin {
    fn build(&self, app: &mut App) {
        app.insert_resource(MapOffset(IVec2::ZERO))
            .insert_resource(TileOffset(Vec2::ZERO))
            .add_systems(OnEnter(GameState::Playing), spawn_tilemap)
            .add_systems(
                Update,
                (
                    handle_scroll_input,
                    update_tile_positions,
                    update_tile_colors, //.run_if(resource_changed::<MapOffset>()),
                )
                    .chain()
                    .run_if(in_state(GameState::Playing)),
            );
    }
}

fn spawn_tilemap(mut commands: Commands, game_assets: Res<GameAssets>) {
    let wall_texture = game_assets.wall_texture.clone();

    for gx in 0..RENDERED_WIDTH {
        for gy in 0..RENDERED_HEIGHT {
            let base_x = (gx as f32 - HALF_WIDTH) * TILE_SIZE;
            let base_y = (gy as f32 - HALF_HEIGHT) * TILE_SIZE;
            let base_pos = Vec2::new(base_x, base_y);

            let grid_pos = IVec2::new(gx as i32, gy as i32);
            let map_pos = grid_pos; // Initial map_offset is ZERO
            let color = get_tile_color(map_pos, &game_assets);

            commands.spawn((
                Sprite {
                    image: wall_texture.clone(),
                    color,
                    ..Default::default()
                },
                Transform::from_xyz(base_x, base_y, 0.0),
                Tile { grid_pos },
                BasePosition(base_pos),
                GameEntity,
            ));
        }
    }
}

fn handle_scroll_input(
    mut tile_offset: ResMut<TileOffset>,
    mut map_offset: ResMut<MapOffset>,
    keys: Res<ButtonInput<KeyCode>>,
    time: Res<Time>,
) {
    let speed = 200.0; // pixels per second, adjust as needed
    let dt = time.delta_secs();

    if keys.pressed(KeyCode::ArrowRight) {
        tile_offset.0.x -= speed * dt;
    }
    if keys.pressed(KeyCode::ArrowLeft) {
        tile_offset.0.x += speed * dt;
    }
    if keys.pressed(KeyCode::ArrowUp) {
        tile_offset.0.y -= speed * dt;
    }
    if keys.pressed(KeyCode::ArrowDown) {
        tile_offset.0.y += speed * dt;
    }

    // Handle x wrapping
    if tile_offset.0.x < -TILE_SIZE {
        tile_offset.0.x += TILE_SIZE;
        map_offset.0.x += 1;
    } else if tile_offset.0.x > TILE_SIZE {
        tile_offset.0.x -= TILE_SIZE;
        map_offset.0.x -= 1;
    }

    // Handle y wrapping
    if tile_offset.0.y < -TILE_SIZE {
        tile_offset.0.y += TILE_SIZE;
        map_offset.0.y += 1;
    } else if tile_offset.0.y > TILE_SIZE {
        tile_offset.0.y -= TILE_SIZE;
        map_offset.0.y -= 1;
    }
}

fn update_tile_positions(
    tile_offset: Res<TileOffset>,
    mut query: Query<(&BasePosition, &mut Transform), With<Tile>>,
) {
    for (base_pos, mut transform) in query.iter_mut() {
        transform.translation = Vec3::new(
            base_pos.0.x + tile_offset.0.x,
            base_pos.0.y + tile_offset.0.y,
            0.0,
        );
    }
}

fn update_tile_colors(
    map_offset: Res<MapOffset>,
    game_assets: Res<GameAssets>,
    mut query: Query<(&Tile, &mut Sprite)>,
) {
    for (tile, mut sprite) in query.iter_mut() {
        let map_pos = map_offset.0 + tile.grid_pos;
        sprite.color = get_tile_color(map_pos, &game_assets);
    }
}

fn get_tile_color(map_pos: IVec2, game_assets: &GameAssets) -> Color {
    let is_wall = (map_pos.x % 5 == 0) || (map_pos.y % 5 == 0);
    if is_wall {
        let index =
            ((map_pos.x.abs() + map_pos.y.abs()) as usize) % game_assets.palette.colors.len();
        game_assets.palette.colors[index]
    } else {
        Color::NONE
    }
}
</tilemap.rs>

<title.rs>
use crate::assets::GameAssets;
use crate::components::{GameEntity, GameState};
use bevy::prelude::*;
use bevy::state::app::AppExtStates;

pub struct TitlePlugin;

impl Plugin for TitlePlugin {
    fn build(&self, app: &mut App) {
        app.init_state::<GameState>()
            .add_systems(OnEnter(GameState::Title), (spawn_title, cleanup_game))
            .add_systems(OnExit(GameState::Title), despawn_title)
            .add_systems(
                Update,
                handle_title_input.run_if(in_state(GameState::Title)),
            );
    }
}

#[derive(Component)]
struct TitleText;

fn spawn_title(mut commands: Commands, game_assets: Res<GameAssets>) {
    let root = commands
        .spawn((
            Node {
                position_type: PositionType::Absolute,
                width: Val::Percent(100.0),
                height: Val::Percent(100.0),
                flex_direction: FlexDirection::Column,
                justify_content: JustifyContent::Center,
                align_items: AlignItems::Center,
                ..default()
            },
            BackgroundColor(Color::NONE),
            TitleText,
        ))
        .id();

    commands.entity(root).with_children(|parent| {
        parent
            .spawn(Node {
                flex_direction: FlexDirection::Row,
                align_items: AlignItems::Start,
                ..default()
            })
            .with_children(|title_row| {
                title_row.spawn((
                    Text::new("GRIDMAN"),
                    TextFont {
                        font: game_assets.font.clone(),
                        font_size: 40.0,
                        ..default()
                    },
                    TextColor(game_assets.palette.colors[3]),
                    TextLayout::new_with_justify(JustifyText::Center),
                ));

                title_row.spawn((
                    Text::new("ECS"),
                    TextFont {
                        font: game_assets.font.clone(),
                        font_size: 12.0, // Smaller font size for superscript
                        ..default()
                    },
                    TextColor(game_assets.palette.colors[2]),
                    TextLayout::new_with_justify(JustifyText::Left),
                ));
            });

        parent.spawn((
            Text::new("FIRE TO PLAY"),
            TextFont {
                font: game_assets.font.clone(),
                font_size: 20.0,
                ..default()
            },
            TextColor(game_assets.palette.colors[4]),
            TextLayout::new_with_justify(JustifyText::Center),
        ));
    });
}

fn despawn_title(mut commands: Commands, query: Query<Entity, With<TitleText>>) {
    for entity in query.iter() {
        commands.entity(entity).despawn();
    }
}

/// Only runs if displaying title screen
fn handle_title_input(
    mut next_state: ResMut<NextState<GameState>>,
    keys: Res<ButtonInput<KeyCode>>,
) {
    if keys.just_pressed(KeyCode::Space) {
        next_state.set(GameState::Playing);
    }
}

fn cleanup_game(mut commands: Commands, query: Query<Entity, With<GameEntity>>) {
    for entity in query.iter() {
        commands.entity(entity).despawn();
    }
}
</title.rs>

<ui_scaling.rs>
use crate::resolution::Resolution;
use bevy::prelude::*;
use bevy::ui::UiScale;
use bevy::window::{PrimaryWindow, WindowResized};

pub struct UiScalingPlugin;

impl Plugin for UiScalingPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Startup, setup_ui_scale)
            .add_systems(Update, update_ui_scale_on_resize);
    }
}

fn setup_ui_scale(
    mut commands: Commands,
    window_query: Query<&Window, With<PrimaryWindow>>,
    resolution: Res<Resolution>,
) {
    let initial_scale = if let Ok(window) = window_query.single() {
        window.resolution.height() / resolution.base_resolution.y
    } else {
        1.0
    };
    commands.insert_resource(UiScale(initial_scale));
}

fn update_ui_scale_on_resize(
    mut resize_events: EventReader<WindowResized>,
    mut ui_scale: ResMut<UiScale>,
    window_query: Query<&Window, With<PrimaryWindow>>,
    resolution: Res<Resolution>,
) {
    for _event in resize_events.read() {
        if let Ok(primary_window) = window_query.single() {
            let current_height = primary_window.resolution.height();
            ui_scale.0 = current_height / resolution.base_resolution.y;
        }
    }
}
</ui_scaling.rs>

