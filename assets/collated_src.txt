<assets.rs>
// assets.rs
use crate::components::GameState;
use bevy::audio::AudioSource;
use bevy::prelude::*;

pub struct AssetsPlugin;

impl Plugin for AssetsPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(OnEnter(GameState::Loading), load_assets);
    }
}

#[derive(Resource, Clone)]
pub struct Palette {
    pub colors: Vec<Color>,
}

#[derive(Resource)]
pub struct GameAssets {
    pub wall_texture: Handle<Image>,
    pub player_texture: Handle<Image>,
    pub reservation_texture: Handle<Image>,
    pub enemy_texture: Handle<Image>,
    pub font: Handle<Font>,
    pub shoot_sfx: Handle<AudioSource>,
    pub palette: Palette,
}

fn load_assets(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    mut next_state: ResMut<NextState<GameState>>,
) {
    let palette = Palette {
        // https://lospec.com/palette-list/gilt-8 by tomicit0
        colors: vec![
            Color::srgb(0.631, 0.224, 0.333),
            Color::srgb(0.761, 0.431, 0.522),
            Color::srgb(0.949, 0.729, 0.800),
            Color::srgb(1.000, 0.949, 0.918),
            Color::srgb(0.984, 0.906, 0.412),
            Color::srgb(0.894, 0.725, 0.169),
            Color::srgb(0.769, 0.416, 0.176),
            Color::srgb(0.506, 0.173, 0.137),
        ],
    };

    commands.insert_resource(GameAssets {
        wall_texture: asset_server.load("textures/wall.png"),
        player_texture: asset_server.load("textures/player.png"),
        reservation_texture: asset_server.load("textures/reservation.png"),
        enemy_texture: asset_server.load("textures/enemy.png"),
        font: asset_server.load("fonts/press_start_2p/PressStart2P-Regular.ttf"),
        shoot_sfx: asset_server.load("sfx/shoot.wav"),
        palette,
    });
    next_state.set(GameState::Title);
}
</assets.rs>

<audio.rs>
// audio.rs
use bevy::audio::{AudioPlayer, PlaybackSettings, Volume};
use bevy::prelude::*;

pub struct AudioPlugin;

impl Plugin for AudioPlugin {
    fn build(&self, _app: &mut App) {
        // No additional setup needed, as AudioPlugin is included in DefaultPlugins
    }
}

/// Plays a sound effect by spawning an entity that will despawn automatically after playback.
/// This is efficient for one-shot SFX and handles cleanup to avoid entity buildup.
pub fn play(commands: &mut Commands, audio: Handle<AudioSource>) {
    commands.spawn((AudioPlayer::new(audio), PlaybackSettings::DESPAWN));
}

pub fn play_with_volume(commands: &mut Commands, audio: Handle<AudioSource>, volume: f32) {
    commands.spawn((
        AudioPlayer::new(audio),
        PlaybackSettings {
            volume: Volume::Linear(volume),
            ..PlaybackSettings::DESPAWN
        },
    ));
}
</audio.rs>

<border.rs>
// border.rs
use crate::components::{GameEntity, GameState};
use crate::resolution::Resolution;
use crate::tilemap::{RENDERED_HEIGHT, RENDERED_WIDTH, TILE_SIZE};
use bevy::prelude::*;
use bevy::window::PrimaryWindow;

#[derive(Component)]
enum BorderSide {
    Left,
    Right,
    Top,
    Bottom,
}

pub struct BorderPlugin;

impl Plugin for BorderPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(OnEnter(GameState::Playing), spawn_borders) //, update_borders))
            .add_systems(
                Update,
                update_borders
                    .run_if(in_state(GameState::Playing).and(resource_changed::<Resolution>)),
            );
    }
}

fn spawn_borders(mut commands: Commands) {
    let z_pos: f32 = 2.;

    commands.spawn((
        Sprite {
            color: Color::srgb(0.1, 0.1, 0.1),
            custom_size: Some(Vec2::ZERO),
            ..default()
        },
        Transform::from_xyz(0.0, 0.0, z_pos),
        BorderSide::Left,
        GameEntity,
    ));
    commands.spawn((
        Sprite {
            color: Color::srgb(0.1, 0.1, 0.1),
            custom_size: Some(Vec2::ZERO),
            ..default()
        },
        Transform::from_xyz(0.0, 0.0, z_pos),
        BorderSide::Right,
        GameEntity,
    ));
    commands.spawn((
        Sprite {
            color: Color::srgb(0.1, 0.1, 0.1),
            custom_size: Some(Vec2::ZERO),
            ..default()
        },
        Transform::from_xyz(0.0, 0.0, z_pos),
        BorderSide::Top,
        GameEntity,
    ));
    commands.spawn((
        Sprite {
            color: Color::srgb(0.1, 0.1, 0.1),
            custom_size: Some(Vec2::ZERO),
            ..default()
        },
        Transform::from_xyz(0.0, 0.0, z_pos),
        BorderSide::Bottom,
        GameEntity,
    ));
}

fn update_borders(
    windows: Query<&Window, With<PrimaryWindow>>,
    cameras: Query<(&Camera, &GlobalTransform), With<Camera2d>>,
    mut borders: Query<(&BorderSide, &mut Transform, &mut Sprite)>,
) {
    let Ok(_window) = windows.single() else {
        return;
    };
    let Ok((camera, global_transform)) = cameras.single() else {
        return;
    };

    let ndc_to_world = |ndc: Vec3| -> Vec3 {
        camera
            .ndc_to_world(global_transform, ndc)
            .unwrap_or(Vec3::ZERO)
    };

    let world_left = ndc_to_world(Vec3::new(-1.0, 0.0, 0.0)).x;
    let world_right = ndc_to_world(Vec3::new(1.0, 0.0, 0.0)).x;
    let world_bottom = ndc_to_world(Vec3::new(0.0, -1.0, 0.0)).y;
    let world_top = ndc_to_world(Vec3::new(0.0, 1.0, 0.0)).y;

    let tilemap_half_w = (RENDERED_WIDTH as f32 / 2.0) * TILE_SIZE;
    let tilemap_half_h = (RENDERED_HEIGHT as f32 / 2.0) * TILE_SIZE;

    let tilemap_left = -tilemap_half_w;
    let tilemap_right = tilemap_half_w - TILE_SIZE;
    let tilemap_bottom = -tilemap_half_h;
    let tilemap_top = tilemap_half_h - TILE_SIZE;

    for (side, mut transform, mut sprite) in &mut borders {
        match side {
            BorderSide::Left => {
                let width = (tilemap_left - world_left).max(0.0);
                let height = world_top - world_bottom;
                let pos_x = world_left + width / 2.0;
                let pos_y = (world_top + world_bottom) / 2.0;
                transform.translation = Vec3::new(pos_x, pos_y, transform.translation.z);
                sprite.custom_size = Some(Vec2::new(width, height));
            }
            BorderSide::Right => {
                let width = (world_right - tilemap_right).max(0.0);
                let height = world_top - world_bottom;
                let pos_x = tilemap_right + width / 2.0;
                let pos_y = (world_top + world_bottom) / 2.0;
                transform.translation = Vec3::new(pos_x, pos_y, transform.translation.z);
                sprite.custom_size = Some(Vec2::new(width, height));
            }
            BorderSide::Top => {
                let height = (world_top - tilemap_top).max(0.0);
                let width = world_right - world_left;
                let pos_y = tilemap_top + height / 2.0;
                let pos_x = (world_right + world_left) / 2.0;
                transform.translation = Vec3::new(pos_x, pos_y, transform.translation.z);
                sprite.custom_size = Some(Vec2::new(width, height));
            }
            BorderSide::Bottom => {
                let height = (tilemap_bottom - world_bottom).max(0.0);
                let width = world_right - world_left;
                let pos_y = world_bottom + height / 2.0;
                let pos_x = (world_right + world_left) / 2.0;
                transform.translation = Vec3::new(pos_x, pos_y, transform.translation.z);
                sprite.custom_size = Some(Vec2::new(width, height));
            }
        }
    }
}
</border.rs>

<collider.rs>
// collider.rs
//use crate::components::GameState;
use bevy::prelude::*;

#[derive(Component)]
pub struct Collider {
    pub size: Vec2,
}

#[derive(Event)]
pub struct Collision {
    pub a: Entity,
    pub b: Entity,
}

pub struct ColliderPlugin;

impl Plugin for ColliderPlugin {
    fn build(&self, _app: &mut App) {
        /*
        app.add_event::<Collision>().add_systems(
            Update,
            detect_collisions.run_if(in_state(GameState::Playing)),
        );
        */
    }
}

fn _detect_collisions(
    mut events: EventWriter<Collision>,
    query: Query<(Entity, &Transform, &Collider)>,
) {
    let entities: Vec<(Entity, Vec2, Vec2)> = query
        .iter()
        .map(|(e, t, c)| (e, t.translation.xy(), c.size))
        .collect();

    for i in 0..entities.len() {
        for j in (i + 1)..entities.len() {
            let (a, pos_a, size_a) = entities[i];
            let (b, pos_b, size_b) = entities[j];

            if _aabb_overlap(pos_a, size_a, pos_b, size_b) {
                events.write(Collision { a, b });
            }
        }
    }
}

fn _aabb_overlap(pos1: Vec2, size1: Vec2, pos2: Vec2, size2: Vec2) -> bool {
    let half1 = size1 / 2.0;
    let half2 = size2 / 2.0;
    let min1 = pos1 - half1;
    let max1 = pos1 + half1;
    let min2 = pos2 - half2;
    let max2 = pos2 + half2;

    min1.x < max2.x && max1.x > min2.x && min1.y < max2.y && max1.y > min2.y
}
</collider.rs>

<components.rs>
use bevy::prelude::*;

#[derive(Clone, Copy, Default, Eq, PartialEq, Hash, States, Debug)]
pub enum GameState {
    #[default]
    Loading,
    Title,
    Playing,
}

#[derive(Component)]
pub struct Dead;

#[derive(Component)]
pub struct GameEntity;

#[derive(Component)]
pub struct Velocity {
    pub velocity: Vec2,
}

#[derive(Component)]
pub struct Speed {
    pub value: f32,
}

#[derive(Event)]
pub struct PlayerDied;

#[derive(Resource)]
pub struct GameSpeed {
    pub value: f32,
}

pub struct ComponentsPlugin;

impl Plugin for ComponentsPlugin {
    fn build(&self, app: &mut App) {
        app.insert_resource(GameSpeed { value: 1.0 }).add_systems(
            Update,
            (update_velocity)
                .chain()
                .run_if(in_state(GameState::Playing)),
        );
    }
}

pub fn update_velocity(
    mut query: Query<(&Velocity, &mut Transform, Option<&Speed>)>,
    time: Res<Time>,
    game_speed: Res<GameSpeed>,
) {
    for (velocity, mut transform, speed) in query.iter_mut() {
        let speed_modifier = speed.map_or(1.0, |s| s.value) * game_speed.value;
        transform.translation.x += velocity.velocity.x * time.delta_secs() * speed_modifier;
        transform.translation.y += velocity.velocity.y * time.delta_secs() * speed_modifier;
    }
}
</components.rs>

<custom_window.rs>
// custom_window_plugin.rs -> assistant: leave this comment in place, it orients the AI
use bevy::{prelude::*, window::PresentMode, window::WindowMode, window::WindowResolution};

const GAME_TITLE: &str = "Gridman ECS";
const BACKGROUND_COLOR: Color = Color::srgb(0.1, 0.1, 0.1);

pub struct CustomWindowPlugin;

impl Plugin for CustomWindowPlugin {
    fn build(&self, app: &mut App) {
        app.insert_resource(ClearColor(BACKGROUND_COLOR))
            .add_plugins(
                DefaultPlugins
                    .set(bevy::window::WindowPlugin {
                        primary_window: Some(Window {
                            title: GAME_TITLE.to_string(),
                            present_mode: PresentMode::AutoNoVsync,
                            mode: WindowMode::Windowed,
                            position: WindowPosition::Centered(MonitorSelection::Primary),
                            resolution: WindowResolution::new(800.0, 600.0),
                            ..default()
                        }),
                        ..default()
                    })
                    .set(ImagePlugin::default_nearest()),
            )
            .add_systems(Update, close_on_esc);
    }
}

pub fn close_on_esc(
    mut commands: Commands,
    focused_windows: Query<(Entity, &Window)>,
    input: Res<ButtonInput<KeyCode>>,
) {
    for (window, focus) in focused_windows.iter() {
        if !focus.focused {
            continue;
        }

        if input.just_pressed(KeyCode::Escape) {
            commands.entity(window).despawn();
        }
    }
}
</custom_window.rs>

<debug.rs>
use crate::assets::GameAssets;
use crate::components::{GameEntity, GameState};
use bevy::diagnostic::{DiagnosticsStore, FrameTimeDiagnosticsPlugin};
use bevy::prelude::*;
use std::time::Duration;

pub struct DebugPlugin;

impl Plugin for DebugPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(OnEnter(GameState::Playing), setup_fps_display)
            .add_systems(
                Update,
                (update_fps_display, test_clear).run_if(in_state(GameState::Playing)),
            );
    }
}

#[derive(Component)]
struct FpsText;

fn setup_fps_display(mut commands: Commands, game_assets: Res<GameAssets>) {
    info!("Setting up FPS display");
    commands.spawn((
        Text::new("FPS: --"),
        TextFont {
            font: game_assets.font.clone(),
            font_size: 8.0,
            ..default()
        },
        TextColor(Color::srgb(0.9, 0.9, 0.9)), // Light gray for minimalist look
        TextLayout::new_with_justify(JustifyText::Left),
        Node {
            position_type: PositionType::Absolute,
            top: Val::Px(10.0),
            left: Val::Px(10.0),
            ..default()
        },
        BackgroundColor(Color::NONE),
        FpsText,
        GameEntity, // Ensures cleanup when exiting GameState::Playing
    ));
}

fn update_fps_display(
    diagnostics: Res<DiagnosticsStore>,
    mut query: Query<&mut Text, With<FpsText>>,
    time: Res<Time>,
    mut timer: Local<Timer>, // Local timer to track update interval
) {
    // Update every 0.5 seconds
    timer.tick(Duration::from_secs_f32(time.delta_secs()));
    if !timer.just_finished() {
        return;
    }
    timer.set_duration(Duration::from_secs_f32(0.5));
    timer.reset();

    if let Ok(mut text) = query.single_mut() {
        // Get FPS from diagnostics
        if let Some(fps) = diagnostics
            .get(&FrameTimeDiagnosticsPlugin::FPS)
            .and_then(|fps| fps.smoothed())
        {
            text.0 = format!("FPS: {:.0}", fps);
        } else {
            info!("FPS diagnostic not available");
            text.0 = "FPS: --".to_string();
        }
    }
}

fn test_clear(keys: Res<ButtonInput<KeyCode>>) {
    if keys.just_pressed(KeyCode::End) {
        info!("END pressed");
    }
}
</debug.rs>

<diagnostics.rs>
// diagnostics.rs
use bevy::{diagnostic::FrameTimeDiagnosticsPlugin, prelude::*};

pub struct DiagnosticsPlugin;

impl Plugin for DiagnosticsPlugin {
    fn build(&self, app: &mut App) {
        app
            // Adds frame time diagnostics (FPS, frame time, etc.)
            .add_plugins(FrameTimeDiagnosticsPlugin::default());
        // Logs diagnostics to the console at regular intervals
        //.add_plugins(LogDiagnosticsPlugin::default())
        // Optional diagnostic plugins (uncomment to enable)
        // .add_plugins(bevy::diagnostic::EntityCountDiagnosticsPlugin::default())
        // .add_plugins(bevy::asset::diagnostic::AssetCountDiagnosticsPlugin::<Texture>::default())
        // .add_plugins(bevy::diagnostic::SystemInformationDiagnosticsPlugin::default());
        //
    }
}
</diagnostics.rs>

<enemy.rs>
// enemy.rs

//! Manages enemy spawning, AI, and behavior.

use bevy::prelude::*;
use bevy_rand::prelude::{GlobalEntropy, WyRand};

use crate::assets::GameAssets;
use crate::collider::Collider;
use crate::components::{GameEntity, GameState};
use crate::grid_movement::{self, GridMover, IntendedDirection, MovementSystems};
use crate::grid_reservation::{GridReservations, GridReserver};
use crate::map::MapData;
use crate::player::DEFAULT_PLAYER_SPEED;
use crate::random::{random_colour, random_float};
use crate::tilemap::TILE_SIZE;

const NUM_LEFT_TURNERS: u32 = 500;
const NUM_RIGHT_TURNERS: u32 = NUM_LEFT_TURNERS;

/// A plugin for all enemy-related logic.
pub struct EnemyPlugin;

impl Plugin for EnemyPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(OnEnter(GameState::Title), setup_enemy_colors)
            .add_systems(OnEnter(GameState::Playing), spawn_enemies)
            .configure_sets(
                Update,
                // The AI systems must run before the movement system to avoid a 1-frame delay.
                EnemyMovementAI.before(MovementSystems::UpdateMover),
            )
            .add_systems(
                Update,
                (update_left_turners, update_right_turners)
                    .in_set(EnemyMovementAI)
                    .run_if(in_state(GameState::Playing)),
            );
    }
}

/// A SystemSet for enemy AI logic to ensure it runs before movement is executed.
#[derive(SystemSet, Debug, Hash, PartialEq, Eq, Clone)]
pub struct EnemyMovementAI;

/// A marker component for any enemy entity.
#[derive(Component)]
pub struct Enemy;

/// A stateful component for enemies that prefer turning left.
#[derive(Component)]
pub struct LeftTurner {
    /// The last direction the enemy was intentionally moving.
    /// This is crucial for making turn decisions after being stopped by a collision.
    pub last_known_direction: IVec2,
}

/// A stateful component for enemies that prefer turning right.
#[derive(Component)]
pub struct RightTurner {
    /// The last direction the enemy was intentionally moving.
    pub last_known_direction: IVec2,
}

/// A resource to store the globally chosen colors for each enemy type.
#[derive(Resource)]
pub struct EnemyColors {
    pub left_turner: Color,
    pub right_turner: Color,
}

/// Runs once to select and store the colors for enemies.
fn setup_enemy_colors(
    mut commands: Commands,
    game_assets: Res<GameAssets>,
    mut rng: GlobalEntropy<WyRand>,
) {
    let color_a = random_colour(&mut rng, &game_assets);
    let mut color_b = random_colour(&mut rng, &game_assets);
    // Ensure the two colors are different.
    while color_a == color_b {
        color_b = random_colour(&mut rng, &game_assets);
    }
    commands.insert_resource(EnemyColors {
        left_turner: color_a,
        right_turner: color_b,
    });
}

/// Spawns all initial enemies in random, valid locations.
fn spawn_enemies(
    mut commands: Commands,
    game_assets: Res<GameAssets>,
    mut rng: GlobalEntropy<WyRand>,
    map_data: Res<MapData>,
    mut reservations: ResMut<GridReservations>,
    enemy_colors: Res<EnemyColors>,
) {
    let valid_directions = [
        IVec2::new(0, 1),
        IVec2::new(0, -1),
        IVec2::new(1, 0),
        IVec2::new(-1, 0),
    ];

    // Spawn LeftTurners
    for _ in 0..NUM_LEFT_TURNERS {
        let (spawn_pos, start_dir) =
            find_valid_spawn(&mut rng, &map_data, &reservations, &valid_directions);

        let entity = commands
            .spawn((
                Sprite {
                    color: enemy_colors.left_turner,
                    image: game_assets.enemy_texture.clone(),
                    ..default()
                },
                Transform::from_xyz(0.0, 0.0, 0.9),
                Enemy,
                GridMover {
                    grid_pos: spawn_pos,
                    direction: IVec2::ZERO,
                    progress: 0.0,
                    speed: 10.0 * DEFAULT_PLAYER_SPEED,
                },
                IntendedDirection(start_dir),
                LeftTurner {
                    last_known_direction: start_dir,
                },
                GridReserver,
                Collider {
                    size: Vec2::splat(TILE_SIZE * 0.5),
                },
                GameEntity,
            ))
            .id();
        reservations.0.insert(spawn_pos, entity);
    }

    // Spawn RightTurners
    for _ in 0..NUM_RIGHT_TURNERS {
        let (spawn_pos, start_dir) =
            find_valid_spawn(&mut rng, &map_data, &reservations, &valid_directions);

        let entity = commands
            .spawn((
                Sprite {
                    color: enemy_colors.right_turner,
                    image: game_assets.enemy_texture.clone(),
                    ..default()
                },
                Transform::from_xyz(0.0, 0.0, 0.9),
                Enemy,
                GridMover {
                    grid_pos: spawn_pos,
                    direction: IVec2::ZERO,
                    progress: 0.0,
                    speed: 10.0 * DEFAULT_PLAYER_SPEED,
                },
                IntendedDirection(start_dir),
                RightTurner {
                    last_known_direction: start_dir,
                },
                GridReserver,
                Collider {
                    size: Vec2::splat(TILE_SIZE * 0.5),
                },
                GameEntity,
            ))
            .id();
        reservations.0.insert(spawn_pos, entity);
    }
}

/// The AI system for LeftTurner enemies.
/// It decides on a new direction when the current path is blocked.
fn update_left_turners(
    mut query: Query<(Entity, &mut IntendedDirection, &GridMover, &mut LeftTurner)>,
    reservations: Res<GridReservations>,
    map_data: Res<MapData>,
) {
    for (entity, mut intended, mover, mut turner) in &mut query {
        // If the entity is moving, update its last known direction and do nothing else.
        if intended.0 != IVec2::ZERO {
            turner.last_known_direction = intended.0;
            continue;
        }

        // The entity has been stopped. Decide where to go next based on its last direction.
        let forward_dir = turner.last_known_direction;
        let current_pos = mover.grid_pos;

        // Priority: Left, Right, Back.
        let left_dir = IVec2::new(forward_dir.y, -forward_dir.x);
        let right_dir = IVec2::new(-forward_dir.y, forward_dir.x);
        let back_dir = -forward_dir;

        let new_dir = if !is_blocked(current_pos + left_dir, entity, &reservations, &map_data) {
            left_dir
        } else if !is_blocked(current_pos + right_dir, entity, &reservations, &map_data) {
            right_dir
        } else {
            back_dir
        };

        intended.0 = new_dir;
        turner.last_known_direction = new_dir;
    }
}

/// The AI system for RightTurner enemies.
/// It decides on a new direction when the current path is blocked.
fn update_right_turners(
    mut query: Query<(Entity, &mut IntendedDirection, &GridMover, &mut RightTurner)>,
    reservations: Res<GridReservations>,
    map_data: Res<MapData>,
) {
    for (entity, mut intended, mover, mut turner) in &mut query {
        // If the entity is moving, update its last known direction and do nothing else.
        if intended.0 != IVec2::ZERO {
            turner.last_known_direction = intended.0;
            continue;
        }

        // The entity has been stopped. Decide where to go next based on its last direction.
        let forward_dir = turner.last_known_direction;
        let current_pos = mover.grid_pos;

        // Priority: Right, Left, Back.
        let right_dir = IVec2::new(-forward_dir.y, forward_dir.x);
        let left_dir = IVec2::new(forward_dir.y, -forward_dir.x);
        let back_dir = -forward_dir;

        let new_dir = if !is_blocked(current_pos + right_dir, entity, &reservations, &map_data) {
            right_dir
        } else if !is_blocked(current_pos + left_dir, entity, &reservations, &map_data) {
            left_dir
        } else {
            back_dir
        };

        intended.0 = new_dir;
        turner.last_known_direction = new_dir;
    }
}

/// Helper to check if a target grid cell is a wall or reserved by another entity.
fn is_blocked(
    target_pos: IVec2,
    self_entity: Entity,
    reservations: &GridReservations,
    map_data: &MapData,
) -> bool {
    if grid_movement::is_wall(target_pos, map_data) {
        return true;
    }
    if let Some(&occupant) = reservations.0.get(&target_pos) {
        // A tile is only blocked if another entity occupies it.
        if occupant != self_entity {
            return true;
        }
    }
    false
}

/// Finds a random, non-wall, non-reserved grid cell to spawn an entity.
fn find_valid_spawn(
    rng: &mut GlobalEntropy<WyRand>,
    map_data: &MapData,
    reservations: &GridReservations,
    directions: &[IVec2],
) -> (IVec2, IVec2) {
    let width = map_data.width as i32;
    let height = map_data.height as i32;

    loop {
        let x = (random_float(rng) * width as f32) as i32;
        let y = (random_float(rng) * height as f32) as i32;
        let pos = IVec2::new(x, y);

        if !grid_movement::is_wall(pos, map_data) && !reservations.0.contains_key(&pos) {
            // Found a valid position. Now find a valid starting direction.
            let start_idx = (random_float(rng) * directions.len() as f32) as usize;
            for i in 0..directions.len() {
                let dir = directions[(start_idx + i) % directions.len()];
                if !grid_movement::is_wall(pos + dir, map_data) {
                    return (pos, dir);
                }
            }
            // If all directions are blocked, we'll loop and find a new spawn point.
        }
    }
}
</enemy.rs>

<game.rs>
use bevy::prelude::*;

use crate::assets;
use crate::audio;
use crate::border;
use crate::collate_src;
use crate::collider;
use crate::components;
use crate::debug;
use crate::diagnostics;
use crate::enemy;
use crate::grid_movement;
use crate::grid_reservation;
use crate::map;
use crate::player;
use crate::projectile;
use crate::random;
use crate::resolution;
use crate::score;
use crate::tilemap;
use crate::title;
use crate::ui_scaling;
pub struct GamePlugin;

impl Plugin for GamePlugin {
    fn build(&self, app: &mut App) {
        app.add_plugins((
            // max of 15 plugins in a tuple
            collate_src::CollateSrcPlugin,
            components::ComponentsPlugin,
            resolution::ResolutionPlugin,
            random::RandomPlugin,
            title::TitlePlugin,
            assets::AssetsPlugin,
            score::ScorePlugin,
            audio::AudioPlugin,
            debug::DebugPlugin,
            ui_scaling::UiScalingPlugin,
            tilemap::TilemapPlugin,
            map::MapPlugin,
            player::PlayerPlugin,
            grid_movement::GridMovementPlugin,
            collider::ColliderPlugin,
        ))
        .add_plugins((
            projectile::ProjectilePlugin,
            border::BorderPlugin,
            grid_reservation::GridReservationPlugin,
            enemy::EnemyPlugin,
            diagnostics::DiagnosticsPlugin,
        ))
        .add_systems(Startup, setup_scene);
    }
}

fn setup_scene(mut commands: Commands) {
    commands.spawn(Camera2d::default());
}
</game.rs>

<grid_movement.rs>
// grid_movement.rs

//! This module defines the core logic for entity movement on a grid.
//!
//! It introduces the `GridMover` component, which tracks an entity's discrete grid position
//! and its progress toward the next tile. The module provides systems to update this state
//! based on an `IntendedDirection` (set by player input or AI), handle wall collisions,
//! and translate the logical grid position into a smooth, visual world position (`Transform`).
//! A `SystemSet` is used to ensure a deterministic order of operations for movement logic.

use bevy::ecs::schedule::SystemSet;
use bevy::prelude::*;

use crate::components::GameState;
use crate::grid_reservation::{GridReservations, GridReserver};
use crate::map::MapData;
use crate::projectile::{Bouncable, Projectile};
use crate::tilemap::{MapOffset, TileOffset, HALF_HEIGHT, HALF_WIDTH, TILE_SIZE};

/// A component that enables grid-based movement for an entity.
#[derive(Component)]
pub struct GridMover {
    /// The entity's current position in integer grid coordinates.
    pub grid_pos: IVec2,
    /// The direction the entity is currently moving (e.g., (1, 0) for right).
    /// A zero vector indicates the entity is stationary.
    pub direction: IVec2,
    /// The progress (0.0 to 1.0) of the movement from `grid_pos` to the next tile.
    /// 0.0 means the entity is perfectly on `grid_pos`; 1.0 means it has arrived at the next tile.
    pub progress: f32,
    /// The speed of the entity, measured in how many pixels it would travel per second.
    /// This is used to calculate the increment of `progress` each frame.
    pub speed: f32,
}

/// A component representing the desired direction of movement for an entity.
///
/// This is decoupled from `GridMover.direction` to allow for input buffering.
/// For example, a player can press a new direction key before the entity has
/// finished moving to the current tile.
#[derive(Component)]
pub struct IntendedDirection(pub IVec2);

/// Defines a strict order of execution for systems related to movement.
///
/// This is crucial to prevent issues like one-frame delays between input and movement,
/// or the camera position being updated before the player's transform. The `.chain()`
/// ensures these sets run sequentially within a single frame.
#[derive(SystemSet, Debug, Hash, PartialEq, Eq, Clone)]
pub enum MovementSystems {
    /// Handles reading input from players or AI to set `IntendedDirection`.
    Input,
    /// Updates the `GridMover` state (progress, direction) based on `IntendedDirection`.
    UpdateMover,
    /// Translates the `GridMover` state into a world-space `Transform` for rendering.
    UpdatePosition,
    /// Adjusts camera/viewport scrolling based on the final entity position.
    AdjustScroll,
    /// Applies any changes to offsets to entity positions.
    ApplyOffsetChanges,
}

/// The plugin that adds all grid movement logic to the application.
pub struct GridMovementPlugin;

impl Plugin for GridMovementPlugin {
    fn build(&self, app: &mut App) {
        app
            // Configure the order of our system sets.
            .configure_sets(
                Update,
                (
                    MovementSystems::Input,
                    MovementSystems::UpdateMover.after(MovementSystems::Input),
                    MovementSystems::UpdatePosition.after(MovementSystems::UpdateMover),
                    MovementSystems::AdjustScroll.after(MovementSystems::UpdatePosition),
                    MovementSystems::ApplyOffsetChanges.after(MovementSystems::AdjustScroll),
                )
                    .chain()
                    .run_if(in_state(GameState::Playing)),
            )
            // Add the systems to their respective sets.
            .add_systems(
                Update,
                update_grid_movement.in_set(MovementSystems::UpdateMover),
            )
            .add_systems(
                Update,
                update_grid_positions.in_set(MovementSystems::UpdatePosition),
            )
            .add_systems(
                Update,
                update_grid_positions
                    .run_if(resource_changed::<MapOffset>.or(resource_changed::<TileOffset>))
                    .in_set(MovementSystems::ApplyOffsetChanges),
            );
    }
}

/// The core system that updates the state of all `GridMover` components.
///
/// This system functions like a state machine for each moving entity. It handles:
/// - Starting movement from a standstill.
/// - Advancing movement progress frame-by-frame.
/// - Reaching a destination tile and deciding what to do next (stop, continue, or change direction).
/// - Handling collisions with walls, including logic for bouncing projectiles.
/// The core system that updates the state of all GridMover components.
#[allow(clippy::too_many_arguments)]
fn update_grid_movement(
    mut commands: Commands,
    mut query: Query<(
        Entity,
        &mut GridMover,
        &mut IntendedDirection,
        Option<&GridReserver>,
        Option<&mut Bouncable>,
        Option<&Projectile>,
    )>,
    time: Res<Time>,
    map_data: Res<MapData>,
    mut reservations: ResMut<GridReservations>,
) {
    for (entity, mut mover, mut intended, reserver, bouncable, projectile) in &mut query {
        // --- State 1: Entity is stationary ---
        if mover.direction == IVec2::ZERO {
            let new_dir = intended.0;
            if new_dir != IVec2::ZERO {
                let next_tile = mover.grid_pos + new_dir;
                // Check if the target tile is valid for movement.
                let is_tile_wall = is_wall(next_tile, &map_data);
                let mut is_tile_reserved = false;

                // Only check for reservations if the entity is a GridReserver.
                if reserver.is_some() {
                    if let Some(&occupant) = reservations.0.get(&next_tile) {
                        // A tile is only considered reserved if it's occupied by another entity.
                        is_tile_reserved = occupant != entity;
                    }
                }

                // Only start moving if the target tile is not a wall and not reserved.
                if !is_tile_wall && !is_tile_reserved {
                    mover.direction = new_dir;
                    mover.progress = 0.0;
                    // If this is a reserver, claim the destination tile.
                    if reserver.is_some() {
                        reservations.0.insert(next_tile, entity);
                    }
                }
            }
        // --- State 2: Entity is currently moving between tiles ---
        } else {
            // Calculate how much to increment progress this frame.
            let dir_vec = mover.direction.as_vec2();
            let dist_factor = dir_vec.length();
            if dist_factor == 0.0 {
                continue; // Avoid division by zero if direction is somehow zero here.
            }
            let inc = mover.speed * time.delta_secs() / (TILE_SIZE * dist_factor);
            mover.progress += inc;

            // --- State 3: Entity has arrived at or passed the destination tile ---
            if mover.progress >= 1.0 {
                let old_pos = mover.grid_pos;
                let current_direction = mover.direction;
                mover.grid_pos += current_direction; // Lock position to the new grid tile.

                // If this entity reserves tiles, free the one it just left.
                if reserver.is_some() {
                    // Only remove the reservation if this entity was the one holding it.
                    if let Some(&occupant) = reservations.0.get(&old_pos) {
                        if occupant == entity {
                            reservations.0.remove(&old_pos);
                        }
                    }
                }

                // Check if the entity wants to continue in the same direction.
                let is_continuing =
                    intended.0 == current_direction && current_direction != IVec2::ZERO;

                if is_continuing {
                    let next_tile = mover.grid_pos + current_direction;
                    let is_tile_wall = is_wall(next_tile, &map_data);
                    let mut is_tile_reserved = false;

                    // Check for reservations if the entity is a GridReserver.
                    if reserver.is_some() {
                        if let Some(&occupant) = reservations.0.get(&next_tile) {
                            is_tile_reserved = occupant != entity;
                        }
                    }

                    if !is_tile_wall && !is_tile_reserved {
                        // Path is clear: carry over the "excess" progress for a smooth transition.
                        mover.progress -= 1.0;
                        // Reserve the new destination tile if this entity is a GridReserver.
                        if reserver.is_some() {
                            reservations.0.insert(next_tile, entity);
                        }
                    } else {
                        // Wall or reserved tile detected ahead.
                        let can_bounce = bouncable.as_ref().map_or(false, |b| b.remaining > 0);
                        if can_bounce {
                            // --- Bouncing Logic ---
                            let new_dir =
                                calculate_reflection(current_direction, mover.grid_pos, &map_data);
                            mover.direction = new_dir;
                            intended.0 = new_dir;
                            if let Some(mut b) = bouncable {
                                b.remaining -= 1;
                            }
                            // Adjust progress based on new direction's length to maintain speed.
                            let old_length = current_direction.as_vec2().length();
                            let new_length = new_dir.as_vec2().length();
                            mover.progress -= 1.0;
                            if new_length > 0.0 && old_length > 0.0 {
                                mover.progress *= old_length / new_length;
                            }
                            // Reserve the new tile after bouncing if this is a reserver.
                            if reserver.is_some() {
                                let next_tile = mover.grid_pos + new_dir;
                                if !is_wall(next_tile, &map_data) {
                                    reservations.0.insert(next_tile, entity);
                                }
                            }
                        } else {
                            // Cannot bounce: stop movement.
                            mover.progress = 0.0;
                            mover.direction = IVec2::ZERO;
                            intended.0 = IVec2::ZERO;
                            // If it's a projectile, despawn it on impact.
                            if projectile.is_some() {
                                commands.entity(entity).despawn();
                            }
                        }
                    }
                } else {
                    // Not continuing straight: reset progress and check for a new direction.
                    mover.progress = 0.0;
                    let new_dir = intended.0;
                    if new_dir != IVec2::ZERO {
                        let next_tile = mover.grid_pos + new_dir;
                        let is_tile_wall = is_wall(next_tile, &map_data);
                        let mut is_tile_reserved = false;

                        // Check for reservations if the entity is a GridReserver.
                        if reserver.is_some() {
                            if let Some(&occupant) = reservations.0.get(&next_tile) {
                                is_tile_reserved = occupant != entity;
                            }
                        }

                        if !is_tile_wall && !is_tile_reserved {
                            mover.direction = new_dir; // Start moving in the new intended direction.
                                                       // Reserve the new destination tile if this is a reserver.
                            if reserver.is_some() {
                                reservations.0.insert(next_tile, entity);
                            }
                        } else {
                            mover.direction = IVec2::ZERO; // New direction is blocked, so stop.
                        }
                    } else {
                        mover.direction = IVec2::ZERO; // No new direction, so stop.
                    }
                }
            }
        }
    }
}

/// Calculates a simple reflection vector for bouncing.
///
/// It checks for open paths horizontally and vertically from the point of impact.
/// - If the horizontal path is clear, it reflects vertically (y -> -y).
/// - If the vertical path is clear, it reflects horizontally (x -> -x).
/// - If both are blocked (a corner), it reflects both (x -> -x, y -> -y).
fn calculate_reflection(dir: IVec2, grid_pos: IVec2, map_data: &MapData) -> IVec2 {
    let dx = dir.x;
    let dy = dir.y;

    // Check adjacent tiles in the direction of velocity components.
    let horiz_next = grid_pos + IVec2::new(dx, 0);
    let vert_next = grid_pos + IVec2::new(0, dy);
    let horiz_clear = !is_wall(horiz_next, map_data);
    let vert_clear = !is_wall(vert_next, map_data);

    if horiz_clear {
        IVec2::new(dx, -dy) // Reflect vertically
    } else if vert_clear {
        IVec2::new(-dx, dy) // Reflect horizontally
    } else {
        IVec2::new(-dx, -dy) // Reflect fully (corner hit)
    }
}

/// Translates the logical `GridMover` position into a final `Transform` for rendering.
///
/// This system runs after `update_grid_movement`, ensuring it uses the most up-to-date
/// grid position and progress. It accounts for the global map and tile offsets to correctly
/// position the entity within the camera's viewport.
fn update_grid_positions(
    map_offset: Res<MapOffset>,
    tile_offset: Res<TileOffset>,
    mut query: Query<(&GridMover, &mut Transform)>,
) {
    for (mover, mut trans) in &mut query {
        // Calculate the effective position, including the fractional progress towards the next tile.
        let effective_pos = mover.grid_pos.as_vec2() + mover.direction.as_vec2() * mover.progress;

        // Convert the effective grid position to world coordinates.
        let x =
            (effective_pos.x - map_offset.0.x as f32 - HALF_WIDTH) * TILE_SIZE + tile_offset.0.x;
        let y =
            (effective_pos.y - map_offset.0.y as f32 - HALF_HEIGHT) * TILE_SIZE + tile_offset.0.y;

        trans.translation.x = x;
        trans.translation.y = y;
    }
}

/// A utility function to check if a given grid position is a wall or out of bounds.
///
/// It performs bounds checking and then looks up the tile type in the `MapData` resource.
/// The Y-coordinate is flipped because the map image data is loaded with (0,0) at the top-left,
/// while our grid coordinates treat (0,0) as the bottom-left.
pub fn is_wall(pos: IVec2, map: &MapData) -> bool {
    // Treat any position outside the map boundaries as a wall.
    if pos.x < 0 || pos.y < 0 || pos.x >= map.width as i32 || pos.y >= map.height as i32 {
        return true;
    }
    let x = pos.x as u32;
    let y = pos.y as u32;

    // Flip Y for lookup in the map data vector.
    let flipped_y = map.height - 1 - y;
    let idx = (flipped_y * map.width + x) as usize;

    // Safely get the value, defaulting to `true` (wall) if the index is somehow out of bounds.
    map.is_wall.get(idx).copied().unwrap_or(true)
}
</grid_movement.rs>

<grid_reservation.rs>
// src/grid_reservation.rs
use crate::assets::GameAssets;
use crate::components::{GameEntity, GameState};
use crate::tilemap::{MapOffset, TileOffset, HALF_HEIGHT, HALF_WIDTH, TILE_SIZE};
use bevy::prelude::*;
use std::collections::{HashMap, HashSet};

/// When set to true, spawns a sprite for each grid cell reservation for debugging.
const VISUAL_DEBUG_RESERVATIONS: bool = !true;

pub struct GridReservationPlugin;

impl Plugin for GridReservationPlugin {
    fn build(&self, app: &mut App) {
        app.init_resource::<GridReservations>()
            // This system runs after all other updates, ensuring that it catches any
            // entities that were despawned during the frame.
            .add_systems(PostUpdate, cleanup_dangling_reservations);

        // If the debug flag is enabled, add the visualization systems.
        if VISUAL_DEBUG_RESERVATIONS {
            app.add_systems(
                Update,
                (sync_reservation_visuals, update_visualizer_positions)
                    .chain()
                    .run_if(in_state(GameState::Playing)),
            );
        }
    }
}

/// A resource that stores a map of reserved grid cells to the entity reserving them.
/// This provides a fast, centralized lookup for collision avoidance.
#[derive(Resource, Default)]
pub struct GridReservations(pub HashMap<IVec2, Entity>);

/// A marker component for entities that should reserve their grid cells.
/// Entities with this component will be unable to move into cells reserved
/// by other entities that also have this component.
#[derive(Component)]
pub struct GridReserver;

/// A marker component for the visual sprite representing a reservation.
/// Stores the grid position it corresponds to.
#[derive(Component)]
struct ReservationVisualizer(IVec2);

/// Spawns and despawns sprites to match the current state of GridReservations.
fn sync_reservation_visuals(
    mut commands: Commands,
    reservations: Res<GridReservations>,
    game_assets: Res<GameAssets>,
    // Query for all existing visualizer entities
    visualizer_query: Query<(Entity, &ReservationVisualizer)>,
) {
    // Collect all grid positions that are currently reserved.
    let needed_visuals: HashSet<IVec2> = reservations.0.keys().cloned().collect();

    // Collect all grid positions that currently have a visualizer sprite.
    let mut current_visuals: HashMap<IVec2, Entity> = HashMap::new();
    for (entity, visualizer) in &visualizer_query {
        current_visuals.insert(visualizer.0, entity);
    }

    // Despawn unneeded visualizers by finding which current ones are no longer needed.
    for (pos, entity) in &current_visuals {
        if !needed_visuals.contains(pos) {
            // Use .despawn() which is idiomatic for Bevy 0.16+
            commands.entity(*entity).despawn();
        }
    }

    // Spawn new visualizers where needed by finding which needed ones don't exist yet.
    for pos in needed_visuals {
        if !current_visuals.contains_key(&pos) {
            commands.spawn((
                Sprite {
                    image: game_assets.reservation_texture.clone(),
                    ..default()
                },
                ReservationVisualizer(pos),
                // GameEntity ensures it's cleaned up when we exit the Playing state.
                GameEntity,
                // The transform will be set correctly by the update_visualizer_positions system.
                // A high Z-value ensures it renders on top of the floor and player.
                Transform::from_xyz(0.0, 0.0, 1.5),
            ));
        }
    }
}

/// Updates the world-space transform of each visualizer sprite based on its grid position
/// and the current camera scroll offsets.
fn update_visualizer_positions(
    map_offset: Res<MapOffset>,
    tile_offset: Res<TileOffset>,
    mut query: Query<(&ReservationVisualizer, &mut Transform)>,
) {
    for (visualizer, mut trans) in &mut query {
        let pos = visualizer.0;

        // This calculation is identical to how other grid-based entities are positioned,
        // ensuring the debug sprite is perfectly centered on the tile.
        let x = (pos.x as f32 - map_offset.0.x as f32 - HALF_WIDTH) * TILE_SIZE + tile_offset.0.x;
        let y = (pos.y as f32 - map_offset.0.y as f32 - HALF_HEIGHT) * TILE_SIZE + tile_offset.0.y;

        trans.translation.x = x;
        trans.translation.y = y;
    }
}

/// A system that cleans up reservations for entities that have been despawned
/// or have had their `GridReserver` component removed.
///
/// This prevents "ghost" reservations from permanently blocking tiles.
fn cleanup_dangling_reservations(
    mut reservations: ResMut<GridReservations>,
    mut removed_reservers: RemovedComponents<GridReserver>,
) {
    // Collect the removed entities into a HashSet for efficient O(1) lookups.
    // In Bevy 0.16, you must use the .read() method to get an iterator.
    let removed_set: HashSet<Entity> = removed_reservers.read().collect();

    // No need to run if no components were removed this frame.
    if removed_set.is_empty() {
        return;
    }

    // Create a temporary Vec of cells to clear. We do this to avoid borrowing `reservations`
    // mutably while iterating over it.
    let cells_to_clear: Vec<IVec2> = reservations
        .0
        .iter()
        // Find all reservations where the entity ID is in our set of removed entities.
        .filter(|(_, &entity)| removed_set.contains(&entity))
        .map(|(&cell, _)| cell)
        .collect();

    for cell in cells_to_clear {
        reservations.0.remove(&cell);
    }
}
</grid_reservation.rs>

<main.rs>
use bevy::prelude::*;

//link our modules to our project

pub mod assets;
pub mod audio;
pub mod border;
pub mod collate_src;
pub mod collider;
pub mod components;
pub mod custom_window;
pub mod debug;
pub mod diagnostics;
pub mod enemy;
pub mod game;
pub mod grid_movement;
pub mod grid_reservation;
pub mod map;
pub mod player;
pub mod projectile;
pub mod random;
pub mod resolution;
pub mod score;
pub mod tilemap;
pub mod title;
pub mod ui_scaling;

fn main() {
    App::new()
        .add_plugins((custom_window::CustomWindowPlugin, game::GamePlugin))
        .run();
}
</main.rs>

<map.rs>
use crate::components::GameState;
use bevy::prelude::*;

#[derive(Resource)]
struct MapHandle(Handle<Image>);

#[derive(Resource)]
pub struct MapData {
    pub width: u32,
    pub height: u32,
    pub is_wall: Vec<bool>,
}

pub struct MapPlugin;

impl Plugin for MapPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(OnEnter(GameState::Loading), load_map)
            .add_systems(Update, process_map.run_if(resource_exists::<MapHandle>));
    }
}

fn load_map(mut commands: Commands, asset_server: Res<AssetServer>) {
    let handle: Handle<Image> = asset_server.load("maps/0.png");
    commands.insert_resource(MapHandle(handle));
}

fn process_map(mut commands: Commands, map_handle: Res<MapHandle>, images: Res<Assets<Image>>) {
    if let Some(image) = images.get(&map_handle.0) {
        let width = image.size().x as u32;
        let height = image.size().y as u32;
        let mut is_wall = vec![false; (width * height) as usize];

        if let Some(data) = &image.data {
            for y in 0..height {
                for x in 0..width {
                    let idx = ((y * width + x) * 4) as usize;
                    // Ensure we don't go out of bounds
                    if idx + 2 < data.len() {
                        let r = data[idx] as f32 / 255.0;
                        let g = data[idx + 1] as f32 / 255.0;
                        let b = data[idx + 2] as f32 / 255.0;
                        // extend the wall on top and right edges to allow for scrolling clamp issue
                        is_wall[(y * width + x) as usize] = r > 0.0
                            || g > 0.0
                            || b > 0.0
                            || y < 2
                            || x >= width - 2
                            || x == 0
                            || y == 0
                            || y == height - 1;
                    }
                }
            }
        }

        commands.insert_resource(MapData {
            width,
            height,
            is_wall,
        });
        commands.remove_resource::<MapHandle>();
    }
}
</map.rs>

<player.rs>
// player.rs

//! Manages the player entity, including its creation, input handling, actions,
//! and the camera scrolling logic that follows it.

use bevy::prelude::*;

use crate::assets::GameAssets;
use crate::audio;
use crate::collider::Collider;
use crate::components::{GameEntity, GameState};
use crate::grid_movement::{is_wall, GridMover, IntendedDirection, MovementSystems};
use crate::grid_reservation::{GridReservations, GridReserver};
use crate::map::MapData;
use crate::projectile::{Bouncable, Projectile};
use crate::random::{random_colour, random_float};
use crate::tilemap::{
    MapOffset, TileOffset, HALF_HEIGHT, HALF_WIDTH, RENDERED_HEIGHT, RENDERED_WIDTH, TILE_SIZE,
};
use bevy_rand::prelude::{GlobalEntropy, WyRand};

/// A plugin responsible for managing player-related logic.
///
/// This plugin registers systems for player spawning, input handling (movement and shooting),
/// and camera scrolling, ensuring they run only when the game is in the `Playing` state.
pub struct PlayerPlugin;

impl Plugin for PlayerPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(OnEnter(GameState::Playing), spawn_player)
            .add_systems(
                Update,
                (
                    // Player input systems are grouped in the `Input` set from MovementSystems.
                    handle_player_input.in_set(MovementSystems::Input),
                    handle_shoot.in_set(MovementSystems::Input),
                    // Camera scrolling logic runs after the player's position has been updated.
                    adjust_scroll_for_buffer.in_set(MovementSystems::AdjustScroll),
                )
                    .run_if(in_state(GameState::Playing)),
            );
    }
}

/// A marker component used to identify the player entity.
#[derive(Component)]
pub struct Player;

/// The base speed multiplier for player and projectile movement.
pub const DEFAULT_PLAYER_SPEED: f32 = 50.0;
/// Defines the size of the "camera deadzone" in tiles. The camera will not scroll
/// until the player moves beyond this buffer area from the center of the screen.
const BUFFER_TILES: Vec2 = Vec2::new(8.0, 8.0);

/// Spawns the player entity at a random, valid (non-wall) location on the map.
///
/// This system runs once when entering the `GameState::Playing` state. It also
/// calculates the initial map and tile offsets to center the camera on the
/// newly spawned player.
fn spawn_player(
    mut commands: Commands,
    game_assets: Res<GameAssets>,
    mut rng: GlobalEntropy<WyRand>,
    map_data: Res<MapData>,
    mut map_offset: ResMut<MapOffset>,
    mut tile_offset: ResMut<TileOffset>,
    mut reservations: ResMut<GridReservations>,
) {
    let width = map_data.width as i32;
    let height = map_data.height as i32;
    let mut mx: i32;
    let mut my: i32;

    // Loop until a valid, non-wall starting position is found.
    loop {
        mx = (random_float(&mut rng) * width as f32) as i32;
        my = (random_float(&mut rng) * height as f32) as i32;
        let flipped_y = (height - 1 - my) as u32; // Map data is stored with Y-axis flipped.
        let idx = (flipped_y * map_data.width + mx as u32) as usize;
        if let Some(&is_wall) = map_data.is_wall.get(idx) {
            if !is_wall {
                break; // Found a valid spot.
            }
        }
    }

    // Calculate the initial integer-based map offset to position the player near the center of the view.
    // This is clamped to ensure the view doesn't go outside the map boundaries.
    let ox =
        ((mx as f32 - HALF_WIDTH).floor() as i32).clamp(0, (width - RENDERED_WIDTH as i32).max(0));
    let oy = ((my as f32 - HALF_HEIGHT).floor() as i32)
        .clamp(0, (height - RENDERED_HEIGHT as i32).max(0));
    map_offset.0 = IVec2::new(ox, oy);

    // Calculate the fractional (sub-tile) offset needed for smooth scrolling.
    let frac_x = mx as f32 - ox as f32 - HALF_WIDTH;
    let frac_y = my as f32 - oy as f32 - HALF_HEIGHT;
    tile_offset.0 = Vec2::new(-frac_x * TILE_SIZE, -frac_y * TILE_SIZE);

    // Spawn the player entity with all its necessary components.
    let player_entity = commands
        .spawn((
            Sprite {
                color: Color::WHITE,
                image: game_assets.player_texture.clone(),
                ..default()
            },
            Transform::from_xyz(0.0, 0.0, 1.0), // Initial position is centered, adjusted by GridMover.
            Player,
            GridMover {
                grid_pos: IVec2::new(mx, my),
                direction: IVec2::ZERO,
                progress: 0.0,
                speed: 20.0 * DEFAULT_PLAYER_SPEED,
            },
            IntendedDirection(IVec2::ZERO),
            GameEntity, // Marker for cleanup when returning to the title screen.
            Collider {
                size: Vec2::splat(TILE_SIZE * 0.5), // A smaller collider than the tile size.
            },
            GridReserver, // Add the reserver component
        ))
        .id();

    // Make the initial reservation for the player's starting cell.
    reservations.0.insert(IVec2::new(mx, my), player_entity);
}

/// Reads keyboard input (W, A, S, D) to set the player's intended direction of movement.
///
/// This system updates the `IntendedDirection` component, which is then used by the
/// `update_grid_movement` system to control the `GridMover`.
fn handle_player_input(
    keys: Res<ButtonInput<KeyCode>>,
    mut query: Query<&mut IntendedDirection, With<Player>>,
) {
    if let Ok(mut intended) = query.single_mut() {
        let mut dx = 0i32;
        if keys.pressed(KeyCode::KeyA) {
            dx -= 1;
        }
        if keys.pressed(KeyCode::KeyD) {
            dx += 1;
        }
        let mut dy = 0i32;
        if keys.pressed(KeyCode::KeyS) {
            dy -= 1;
        }
        if keys.pressed(KeyCode::KeyW) {
            dy += 1;
        }
        intended.0 = IVec2::new(dx, dy);
    }
}

/// Handles the player's shooting action based on keyboard input.
///
/// When the Space key is pressed, this system spawns a projectile entity.
/// The projectile is spawned one tile ahead of the player in their current
/// intended direction of movement. No projectile is fired if the player is stationary
/// or aiming at a wall.
fn handle_shoot(
    keys: Res<ButtonInput<KeyCode>>,
    mut commands: Commands,
    mut rng: GlobalEntropy<WyRand>,
    game_assets: Res<GameAssets>,
    query: Query<(&GridMover, &IntendedDirection), With<Player>>,
    map_data: Res<MapData>,
) {
    // Check for the shoot button press.
    if keys.just_pressed(KeyCode::Space) {
        if let Ok((mover, intended)) = query.single() {
            info!("space pressed");
            // Only shoot if the player has a direction.
            if intended.0 != IVec2::ZERO {
                let dir = intended.0;
                let spawn_pos = mover.grid_pos + dir; // Spawn in the next tile over.

                // Prevent spawning a projectile inside a wall.
                if is_wall(spawn_pos, &map_data) {
                    return;
                }
                let color = random_colour(&mut rng, &game_assets);

                // Spawn the projectile entity.
                commands.spawn((
                    Sprite {
                        color,
                        image: game_assets.player_texture.clone(), // Uses player texture for now.
                        ..default()
                    },
                    Transform::from_xyz(0.0, 0.0, 1.0),
                    Projectile,
                    GridMover {
                        grid_pos: spawn_pos,
                        direction: IVec2::ZERO, // Initially stationary, will move on next frame.
                        progress: 0.0,
                        speed: 30.0 * DEFAULT_PLAYER_SPEED,
                    },
                    IntendedDirection(dir), // The projectile continues in the player's direction.
                    Bouncable { remaining: 3 }, // Can bounce off walls 3 times.
                    Collider {
                        size: Vec2::splat(TILE_SIZE * 0.5),
                    },
                    GameEntity,
                ));
                // Play the shooting sound effect.
                audio::play(&mut commands, game_assets.shoot_sfx.clone());
            }
        }
    }
}

/// Implements camera scrolling by adjusting map and tile offsets.
///
/// This function creates a "deadzone" or buffer around the center of the screen. The
/// map remains static until the player moves outside this buffer. Once the player crosses
/// the buffer boundary, the `tile_offset` is adjusted to smoothly scroll the world,
/// keeping the player within the buffer. When the `tile_offset` exceeds the size of a
/// full tile, it "wraps around," and the integer-based `map_offset` is updated. This
/// entire process is clamped to prevent the camera from scrolling past the map's edges.
fn adjust_scroll_for_buffer(
    query_player: Query<&Transform, With<Player>>,
    mut map_offset: ResMut<MapOffset>,
    mut tile_offset: ResMut<TileOffset>,
    map_data: Res<MapData>,
) {
    // Calculate the pixel dimensions of the central buffer zone.
    let half_buffer = BUFFER_TILES * TILE_SIZE / 2.0;

    if let Ok(player_tr) = query_player.single() {
        let p = player_tr.translation.xy();
        let mut delta = Vec2::ZERO;

        // Check if the player's screen position has exceeded the buffer boundaries.
        if p.x > half_buffer.x {
            delta.x = p.x - half_buffer.x;
        } else if p.x < -half_buffer.x {
            delta.x = p.x + half_buffer.x;
        }
        if p.y > half_buffer.y {
            delta.y = p.y - half_buffer.y;
        } else if p.y < -half_buffer.y {
            delta.y = p.y + half_buffer.y;
        }

        // If the player is outside the buffer, adjust the tile offset to scroll the map.
        if delta != Vec2::ZERO {
            tile_offset.0 -= delta;
        }
    }

    // Define map and view dimensions for clamping.
    let map_width_i = map_data.width as i32;
    let map_height_i = map_data.height as i32;
    let view_width = RENDERED_WIDTH as i32;
    let view_height = RENDERED_HEIGHT as i32;
    let max_map_x = (map_width_i - view_width).max(0);
    let max_map_y = (map_height_i - view_height).max(0);

    // This section handles the "wrapping" of the tile_offset into the map_offset
    // and clamps the final view position to the map boundaries.

    // Handle X-axis scrolling and clamping.
    let mut view_left = map_offset.0.x as f32 - tile_offset.0.x / TILE_SIZE;
    view_left = view_left.clamp(0.0, max_map_x as f32);
    map_offset.0.x = view_left.floor() as i32;
    tile_offset.0.x = -(view_left - map_offset.0.x as f32) * TILE_SIZE;

    // Handle Y-axis scrolling and clamping.
    let mut view_top = map_offset.0.y as f32 - tile_offset.0.y / TILE_SIZE;
    view_top = view_top.clamp(0.0, max_map_y as f32);
    map_offset.0.y = view_top.floor() as i32;
    tile_offset.0.y = -(view_top - map_offset.0.y as f32) * TILE_SIZE;
}
</player.rs>

<projectile.rs>
// projectile.rs
use bevy::prelude::*;

//use crate::components::GameState;
//use crate::grid_movement::MovementSystems;

#[derive(Component)]
pub struct Projectile;

#[derive(Component)]
pub struct Bouncable {
    pub remaining: u32,
}

pub struct ProjectilePlugin;

impl Plugin for ProjectilePlugin {
    fn build(&self, _app: &mut App) {
        // No additional setup needed, as AudioPlugin is included in DefaultPlugins
    }
}
</projectile.rs>

<random.rs>
// src/random.rs

use bevy::prelude::*;
// Import WyRand and the necessary query components from bevy_rand
use bevy_rand::prelude::{EntropyPlugin, GlobalEntropy, WyRand};

use crate::assets::GameAssets;
use rand_core::RngCore;
use std::time::{SystemTime, UNIX_EPOCH};

/// Plugin for handling random number generation with WyRand
#[derive(Debug, Clone, Copy, Default)]
pub struct RandomPlugin;

impl Plugin for RandomPlugin {
    fn build(&self, app: &mut App) {
        let seed = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .expect("Time went backwards")
            .as_nanos() as u64;

        // The `with_seed` function expects a byte array.
        // We convert the u64 seed to a little-endian byte array.
        app.add_plugins(EntropyPlugin::<WyRand>::with_seed(seed.to_le_bytes()));
    }
}

pub fn random_float(rng: &mut GlobalEntropy<WyRand>) -> f32 {
    (rng.next_u32() as f32) / (u32::MAX as f32)
}

/// Returns a random color from the GameAssets palette
pub fn random_colour(rng: &mut GlobalEntropy<WyRand>, game_assets: &Res<GameAssets>) -> Color {
    let palette = &game_assets.palette;
    let index = (random_float(rng) * palette.colors.len() as f32) as usize;
    palette.colors[index]
}
</random.rs>

<resolution.rs>
use bevy::prelude::*;
use bevy::window::{PrimaryWindow, WindowResized};

pub struct ResolutionPlugin;

impl Plugin for ResolutionPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(PreStartup, setup_resolution).add_systems(
            Update,
            (handle_window_resize, update_camera_projection).chain(),
        );
    }
}

// Increasing this value will result in the projection zooming out, showing more of the render area
const MASTER_SCALE: f32 = 4.0;

#[derive(Resource)]
pub struct Resolution {
    // Pixel dimensions of the screen (width, height)
    pub screen_dimensions: Vec2,
    // The ratio of a pixel in our sprites to one on screen
    pub pixel_ratio: f32,
    // Base resolution for scaling (e.g., the design resolution)
    pub base_resolution: Vec2,
    // Decrease to show more onscreen 0..1
    pub zoom: f32,
}

fn setup_resolution(mut commands: Commands, window_query: Query<&Window, With<PrimaryWindow>>) {
    if let Ok(window) = window_query.single() {
        let width = window.resolution.width();
        let height = window.resolution.height();

        commands.insert_resource(Resolution {
            screen_dimensions: Vec2::new(width, height),
            pixel_ratio: window.scale_factor() as f32,
            base_resolution: Vec2::new(800.0, 600.0),
            zoom: 1.0,
        });
    } else {
        error!("No primary window found during resolution setup");
        // Fallback to default resolution
        commands.insert_resource(Resolution {
            screen_dimensions: Vec2::new(800.0, 600.0),
            pixel_ratio: 1.0,
            base_resolution: Vec2::new(800.0, 600.0),
            zoom: 1.0,
        });
    }
}

fn handle_window_resize(
    mut resize_events: EventReader<WindowResized>,
    mut resolution: ResMut<Resolution>,
    // Query for the Entity and the Window component of the primary window
    window_query: Query<(Entity, &Window), With<PrimaryWindow>>,
) {
    // Get the entity and component for the primary window
    if let Ok((primary_window_entity, primary_window)) = window_query.single() {
        for event in resize_events.read() {
            // Compare the event's entity with the primary window's entity
            if event.window == primary_window_entity {
                resolution.screen_dimensions = Vec2::new(event.width, event.height);
                resolution.pixel_ratio = primary_window.scale_factor() as f32;
                info!("Window resized to {}x{}", event.width, event.height);
            }
        }
    }
}

fn update_camera_projection(
    resolution: Res<Resolution>,
    mut query: Query<&mut Projection, With<Camera2d>>,
) {
    if resolution.is_changed() {
        for mut projection in query.iter_mut() {
            if let Projection::Orthographic(ref mut ortho) = &mut *projection {
                let scale_x = resolution.screen_dimensions.x / resolution.base_resolution.x;
                let scale_y = resolution.screen_dimensions.y / resolution.base_resolution.y;
                // Use the smaller scale to maintain aspect ratio and avoid stretching
                let scale = scale_x.min(scale_y) * resolution.pixel_ratio;

                ortho.scale = (MASTER_SCALE * resolution.zoom) * 1.0 / scale;
                info!("Updated camera projection scale: {}", ortho.scale);
            }
        }
    }
}
</resolution.rs>

<score.rs>
// score.rs
use bevy::prelude::*;

use crate::assets::GameAssets;
use crate::components::{GameEntity, GameState};

pub struct ScorePlugin;

impl Plugin for ScorePlugin {
    fn build(&self, app: &mut App) {
        app.add_event::<ScoreChanged>()
            .add_systems(OnEnter(GameState::Playing), setup_score)
            .add_systems(
                Update,
                (update_score, update_score_display)
                    .chain()
                    .run_if(in_state(GameState::Playing)),
            );
    }
}

#[derive(Resource)]
pub struct Score {
    pub value: u32,
}

#[derive(Event)]
pub struct ScoreChanged;

#[derive(Component)]
struct ScoreText;

fn setup_score(mut commands: Commands, game_assets: Res<GameAssets>) {
    commands.insert_resource(Score { value: 0 });

    let root = commands
        .spawn((
            Node {
                position_type: PositionType::Absolute,
                top: Val::Px(10.0),
                width: Val::Percent(100.0),
                height: Val::Px(60.0),
                flex_direction: FlexDirection::Column,
                justify_content: JustifyContent::FlexStart,
                align_items: AlignItems::Center,
                ..default()
            },
            BackgroundColor(Color::NONE),
            GameEntity,
        ))
        .id();

    commands.entity(root).with_children(|parent| {
        parent.spawn((
            Text::new("0000".to_string()),
            TextFont {
                font: game_assets.font.clone(),
                font_size: 16.0,
                ..default()
            },
            TextColor(game_assets.palette.colors[3]),
            TextLayout::new_with_justify(JustifyText::Center),
            ScoreText,
        ));
    });
}

fn update_score(mut score: ResMut<Score>, mut events: EventReader<ScoreChanged>) {
    for _ in events.read() {
        score.value += 1;
        if score.value > 9999 {
            score.value = 9999;
        }
    }
}

fn update_score_display(score: Res<Score>, mut query: Query<&mut Text, With<ScoreText>>) {
    if score.is_changed() {
        if let Ok(mut text) = query.single_mut() {
            text.0 = format!("{:04}", score.value);
        }
    }
}
</score.rs>

<tilemap.rs>
// tilemap.rs
use bevy::prelude::*;
use bevy::sprite::Sprite;
use bevy_rand::prelude::{GlobalEntropy, WyRand};

use crate::assets::GameAssets;
use crate::components::{GameEntity, GameState};
use crate::map::MapData;
use crate::random::random_colour;

pub const TILE_SIZE: f32 = 64.0;
pub const RENDERED_WIDTH: usize = 32;
pub const RENDERED_HEIGHT: usize = 26;
pub const HALF_WIDTH: f32 = (RENDERED_WIDTH as f32 - 1.0) / 2.0;
pub const HALF_HEIGHT: f32 = (RENDERED_HEIGHT as f32 - 1.0) / 2.0;
/// Defines the size of one side of a checkerboard square, in tiles.
pub const CHECKER_SIZE: u32 = 4;

#[derive(Resource)]
pub struct MapOffset(pub IVec2);

#[derive(Resource)]
pub struct TileOffset(pub Vec2);

/// A resource to hold the two darkened, randomized colors for the floor pattern.
#[derive(Resource)]
pub struct FloorPalette {
    pub color_a: Color,
    pub color_b: Color,
}

#[derive(Component)]
pub struct Tile {
    pub grid_pos: IVec2,
}

#[derive(Component)]
pub struct BasePosition(pub Vec2);

pub struct TilemapPlugin;

impl Plugin for TilemapPlugin {
    fn build(&self, app: &mut App) {
        app.insert_resource(MapOffset(IVec2::ZERO))
            .insert_resource(TileOffset(Vec2::ZERO))
            .add_systems(
                OnEnter(GameState::Playing),
                (
                    setup_initial_offset,
                    setup_floor_palette, // Create the random palette
                    spawn_tilemap,
                )
                    .chain(),
            )
            .add_systems(
                Update,
                ((update_tile_positions, update_tile_colors)
                    .run_if(resource_changed::<MapOffset>.or(resource_changed::<TileOffset>)),)
                    .chain()
                    .run_if(in_state(GameState::Playing)),
            );
    }
}

/// A new system that runs once to create and store the floor palette.
/// It picks two random colors, darkens them, and inserts them as a resource.
fn setup_floor_palette(
    mut commands: Commands,
    game_assets: Res<GameAssets>,
    mut rng: GlobalEntropy<WyRand>,
) {
    // pick 2 random different colours from our palette
    let mut color_a = random_colour(&mut rng, &game_assets);
    let mut color_b = random_colour(&mut rng, &game_assets);
    while color_a == color_b {
        color_b = random_colour(&mut rng, &game_assets);
    }

    // darken them
    let darken_factor = 0.25;
    color_a = darken(color_a, darken_factor);
    color_b = darken(color_b, darken_factor);

    // and insert them into a resource
    commands.insert_resource(FloorPalette {
        color_a: color_a,
        color_b: color_b,
    });
}

fn darken(c: Color, darken_factor: f32) -> Color {
    match c {
        Color::Srgba(mut srgba) => {
            srgba.red *= darken_factor;
            srgba.green *= darken_factor;
            srgba.blue *= darken_factor;
            Color::Srgba(srgba)
        }
        _ => c,
    }
}

// center map in viewport
fn setup_initial_offset(map_data: Res<MapData>, mut map_offset: ResMut<MapOffset>) {
    let view_w = RENDERED_WIDTH as i32;
    let view_h = RENDERED_HEIGHT as i32;
    let map_w = map_data.width as i32;
    let map_h = map_data.height as i32;
    map_offset.0.x = ((map_w - view_w) / 2).max(0);
    map_offset.0.y = ((map_h - view_h) / 2).max(0);
}

// spawns the viewable section of the tilemap, with each visible tile being an individual sprite entity
fn spawn_tilemap(
    mut commands: Commands,
    game_assets: Res<GameAssets>,
    map_data: Res<MapData>,
    map_offset: Res<MapOffset>,
    floor_palette: Res<FloorPalette>, // Get the newly created floor palette
) {
    let wall_texture = game_assets.wall_texture.clone();

    for gx in 0..RENDERED_WIDTH {
        for gy in 0..RENDERED_HEIGHT {
            let base_x = (gx as f32 - HALF_WIDTH) * TILE_SIZE;
            let base_y = (gy as f32 - HALF_HEIGHT) * TILE_SIZE;
            let base_pos = Vec2::new(base_x, base_y);

            let grid_pos = IVec2::new(gx as i32, gy as i32);
            let map_pos = grid_pos + map_offset.0;
            // Pass the palette to the color logic function
            let color = get_tile_color(map_pos, &game_assets, &map_data, &floor_palette);

            commands.spawn((
                Sprite {
                    image: wall_texture.clone(),
                    color,
                    ..Default::default()
                },
                Transform::from_xyz(base_x, base_y, 0.0),
                Tile { grid_pos },
                BasePosition(base_pos),
                GameEntity,
            ));
        }
    }
}

fn update_tile_positions(
    tile_offset: Res<TileOffset>,
    mut query: Query<(&BasePosition, &mut Transform), With<Tile>>,
) {
    for (base_pos, mut transform) in query.iter_mut() {
        transform.translation = Vec3::new(
            base_pos.0.x + tile_offset.0.x,
            base_pos.0.y + tile_offset.0.y,
            0.0,
        );
    }
}

/// Updated to determine tile color based on walls and the new checkerboard floor.
fn get_tile_color(
    map_pos: IVec2,
    game_assets: &GameAssets,
    map_data: &MapData,
    floor_palette: &FloorPalette,
) -> Color {
    // First, check if the position is within the map's boundaries.
    // If not, return a transparent color to avoid drawing outside the map area.
    if map_pos.x < 0
        || map_pos.y < 0
        || map_pos.x >= map_data.width as i32
        || map_pos.y >= map_data.height as i32
    {
        return Color::NONE;
    }

    // Determine if the current tile is a wall.
    let x = map_pos.x as u32;
    let y = map_pos.y as u32;
    let flipped_y = map_data.height - 1 - y;
    let idx = (flipped_y * map_data.width + x) as usize;
    let is_wall = map_data.is_wall.get(idx).copied().unwrap_or(false);

    if is_wall {
        // It's a wall, so calculate its color based on its position.
        let index =
            ((map_pos.x.abs() + map_pos.y.abs()) as usize) % game_assets.palette.colors.len();
        game_assets.palette.colors[index]
    } else {
        // It's a floor tile, so apply the checkerboard pattern.
        // Use Euclidean division to handle potential negative coordinates gracefully.
        let checker_x = map_pos.x.div_euclid(CHECKER_SIZE as i32);
        let checker_y = map_pos.y.div_euclid(CHECKER_SIZE as i32);
        if (checker_x + checker_y) % 2 == 0 {
            floor_palette.color_a
        } else {
            floor_palette.color_b
        }
    }
}

/// Updated to pass the FloorPalette resource to the color logic.
fn update_tile_colors(
    map_offset: Res<MapOffset>,
    game_assets: Res<GameAssets>,
    map_data: Res<MapData>,
    floor_palette: Res<FloorPalette>, // Get the floor palette
    mut query: Query<(&Tile, &mut Sprite)>,
) {
    for (tile, mut sprite) in query.iter_mut() {
        let map_pos = map_offset.0 + tile.grid_pos;
        // Pass the palette to the color logic function
        sprite.color = get_tile_color(map_pos, &game_assets, &map_data, &floor_palette);
    }
}
</tilemap.rs>

<title.rs>
use crate::assets::GameAssets;
use crate::components::{GameEntity, GameState};
use bevy::prelude::*;
use bevy::state::app::AppExtStates;

pub struct TitlePlugin;

impl Plugin for TitlePlugin {
    fn build(&self, app: &mut App) {
        app.init_state::<GameState>()
            .add_systems(OnEnter(GameState::Title), (spawn_title, cleanup_game))
            .add_systems(OnExit(GameState::Title), despawn_title)
            .add_systems(
                Update,
                handle_title_input.run_if(in_state(GameState::Title)),
            );
    }
}

#[derive(Component)]
struct TitleText;

fn spawn_title(mut commands: Commands, game_assets: Res<GameAssets>) {
    let root = commands
        .spawn((
            Node {
                position_type: PositionType::Absolute,
                width: Val::Percent(100.0),
                height: Val::Percent(100.0),
                flex_direction: FlexDirection::Column,
                justify_content: JustifyContent::Center,
                align_items: AlignItems::Center,
                ..default()
            },
            BackgroundColor(Color::NONE),
            TitleText,
        ))
        .id();

    commands.entity(root).with_children(|parent| {
        parent
            .spawn(Node {
                flex_direction: FlexDirection::Row,
                align_items: AlignItems::Start,
                ..default()
            })
            .with_children(|title_row| {
                title_row.spawn((
                    Text::new("GRIDMAN"),
                    TextFont {
                        font: game_assets.font.clone(),
                        font_size: 40.0,
                        ..default()
                    },
                    TextColor(game_assets.palette.colors[3]),
                    TextLayout::new_with_justify(JustifyText::Center),
                ));

                title_row.spawn((
                    Text::new("ECS"),
                    TextFont {
                        font: game_assets.font.clone(),
                        font_size: 12.0, // Smaller font size for superscript
                        ..default()
                    },
                    TextColor(game_assets.palette.colors[2]),
                    TextLayout::new_with_justify(JustifyText::Left),
                ));
            });

        parent.spawn((
            Text::new("FIRE TO PLAY"),
            TextFont {
                font: game_assets.font.clone(),
                font_size: 20.0,
                ..default()
            },
            TextColor(game_assets.palette.colors[4]),
            TextLayout::new_with_justify(JustifyText::Center),
        ));
    });
}

fn despawn_title(mut commands: Commands, query: Query<Entity, With<TitleText>>) {
    for entity in query.iter() {
        commands.entity(entity).despawn();
    }
}

/// Only runs if displaying title screen
fn handle_title_input(
    mut next_state: ResMut<NextState<GameState>>,
    keys: Res<ButtonInput<KeyCode>>,
) {
    if keys.just_pressed(KeyCode::Space) {
        next_state.set(GameState::Playing);
    }
}

fn cleanup_game(mut commands: Commands, query: Query<Entity, With<GameEntity>>) {
    for entity in query.iter() {
        commands.entity(entity).despawn();
    }
}
</title.rs>

<ui_scaling.rs>
use crate::resolution::Resolution;
use bevy::prelude::*;
use bevy::ui::UiScale;
use bevy::window::{PrimaryWindow, WindowResized};

pub struct UiScalingPlugin;

impl Plugin for UiScalingPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Startup, setup_ui_scale)
            .add_systems(Update, update_ui_scale_on_resize);
    }
}

fn setup_ui_scale(
    mut commands: Commands,
    window_query: Query<&Window, With<PrimaryWindow>>,
    resolution: Res<Resolution>,
) {
    let initial_scale = if let Ok(window) = window_query.single() {
        window.resolution.height() / resolution.base_resolution.y
    } else {
        1.0
    };
    commands.insert_resource(UiScale(initial_scale));
}

fn update_ui_scale_on_resize(
    mut resize_events: EventReader<WindowResized>,
    mut ui_scale: ResMut<UiScale>,
    window_query: Query<&Window, With<PrimaryWindow>>,
    resolution: Res<Resolution>,
) {
    for _event in resize_events.read() {
        if let Ok(primary_window) = window_query.single() {
            let current_height = primary_window.resolution.height();
            ui_scale.0 = current_height / resolution.base_resolution.y;
        }
    }
}
</ui_scaling.rs>

